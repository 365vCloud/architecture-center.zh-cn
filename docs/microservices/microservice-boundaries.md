---
title: 识别微服务边界
description: 识别微服务边界
author: MikeWasson
ms.date: 12/08/2017
ms.openlocfilehash: d35b92ffd97c4fda5d6599340925ce3dfea7f15b
ms.sourcegitcommit: a5e549c15a948f6fb5cec786dbddc8578af3be66
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/06/2018
---
# <a name="designing-microservices-identifying-microservice-boundaries"></a><span data-ttu-id="7f9f6-103">设计微服务：识别微服务边界
</span><span class="sxs-lookup"><span data-stu-id="7f9f6-103">Designing microservices: Identifying microservice boundaries</span></span>

<span data-ttu-id="7f9f6-104">微服务的适当大小是什么？</span><span class="sxs-lookup"><span data-stu-id="7f9f6-104">What is the right size for a microservice?</span></span> <span data-ttu-id="7f9f6-105">我们经常听到有人说，“不要太大，也不要太小”&mdash; 这句话绝对正确，但实际上没有太大意义。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-105">You often hear something to the effect of, "not too big and not too small" &mdash; and while that's certainly correct, it's not very helpful in practice.</span></span> <span data-ttu-id="7f9f6-106">但是，如果从一个精心设计的领域模型着手，则规划出微服务就容易得多。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-106">But if you start from a carefully designed domain model, it's much easier to reason about microservices.</span></span>

![](./images/bounded-contexts.png)

## <a name="from-domain-model-to-microservices"></a><span data-ttu-id="7f9f6-107">从领域模型到微服务</span><span class="sxs-lookup"><span data-stu-id="7f9f6-107">From domain model to microservices</span></span>

<span data-ttu-id="7f9f6-108">在[前面的章节](./domain-analysis.md)中，我们为无人机交付应用程序定义了一组边界上下文。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-108">In the [previous chapter](./domain-analysis.md), we defined a set of bounded contexts for the Drone Delivery application.</span></span> <span data-ttu-id="7f9f6-109">然后，我们更详细地探讨了其中的某个边界上下文（“交货”边界上下文），并为该边界上下文标识了一组实体、聚合和领域服务。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-109">Then we looked more closely at one of these bounded contexts, the Shipping bounded context, and identified a set of entities, aggregates, and domain services for that bounded context.</span></span>

<span data-ttu-id="7f9f6-110">现在，我们可以从领域模型转到应用程序设计。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-110">Now we're ready to go from domain model to application design.</span></span> <span data-ttu-id="7f9f6-111">下面介绍了一个可以从领域模型派生微服务的方法。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-111">Here's an approach that you can use to derive microservices from the domain model.</span></span>

1. <span data-ttu-id="7f9f6-112">从边界上下文着手。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-112">Start with a bounded context.</span></span> <span data-ttu-id="7f9f6-113">一般而言，微服务中的功能不应跨越多个边界上下文。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-113">In general, the functionality in a microservice should not span more than one bounded context.</span></span> <span data-ttu-id="7f9f6-114">根据定义，边界上下文标记特定领域模型的边界。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-114">By definition, a bounded context marks the boundary of a particular domain model.</span></span> <span data-ttu-id="7f9f6-115">如果你发现微服务混用了不同的领域模型，可能意味着需要重新进行领域分析以优化领域模型。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-115">If you find that a microservice mixes different domain models together, that's a sign that you may need to go back and refine your domain analysis.</span></span>

2. <span data-ttu-id="7f9f6-116">接下来，查看领域模型中的聚合。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-116">Next, look at the aggregates in your domain model.</span></span> <span data-ttu-id="7f9f6-117">聚合通常是微服务的适当候选项。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-117">Aggregates are often good candidates for microservices.</span></span> <span data-ttu-id="7f9f6-118">合理设计的聚合能够体现一个设计优良的微服务的许多特征，例如：</span><span class="sxs-lookup"><span data-stu-id="7f9f6-118">A well-designed aggregate exhibits many of the characteristics of a well-designed microservice, such as:</span></span>

    - <span data-ttu-id="7f9f6-119">聚合派生自业务要求，而不是数据访问或消息传递等技术因素。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-119">An aggregate is derived from business requirements, rather than technical concerns such as data access or messaging.</span></span>  
    - <span data-ttu-id="7f9f6-120">聚合应具有较高的功能内聚性。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-120">An aggregate should have high functional cohesion.</span></span>
    - <span data-ttu-id="7f9f6-121">聚合是持久性边界。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-121">An aggregate is a boundary of persistence.</span></span>
    - <span data-ttu-id="7f9f6-122">聚合应松散耦合。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-122">Aggregates should be loosely coupled.</span></span> 
    
3. <span data-ttu-id="7f9f6-123">领域服务也是微服务的适当候选项。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-123">Domain services are also good candidates for microservices.</span></span> <span data-ttu-id="7f9f6-124">领域服务针对多个聚合执行无状态操作。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-124">Domain services are stateless operations across multiple aggregates.</span></span> <span data-ttu-id="7f9f6-125">一个典型的示例是涉及多个微服务的工作流。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-125">A typical example is a workflow that involves several microservices.</span></span> <span data-ttu-id="7f9f6-126">可在无人机交付应用程序中看到此示例。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-126">We'll see an example of this in the Drone Delivery application.</span></span>

4. <span data-ttu-id="7f9f6-127">最后，考虑非功能性要求。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-127">Finally, consider non-functional requirements.</span></span> <span data-ttu-id="7f9f6-128">分析团队规模、数据类型、技术、可伸缩性要求、可用性要求和安全要求等因素。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-128">Look at factors such as team size, data types, technologies, scalability requirements, availability requirements, and security requirements.</span></span> <span data-ttu-id="7f9f6-129">这些因素可能导致需要进一步将微服务分解成两个或更多个较小服务，或执行相反的操作，即，将多个微服务合并成一个。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-129">These factors may lead you to further decompose a microservice into two or more smaller services, or do the opposite and combine several microservices into one.</span></span> 

<span data-ttu-id="7f9f6-130">在应用程序中标识微服务之后，请根据以下条件验证设计：</span><span class="sxs-lookup"><span data-stu-id="7f9f6-130">After you identify the microservices in your application, validate your design against the following criteria:</span></span>

- <span data-ttu-id="7f9f6-131">每个服务承担单一责任。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-131">Each service has a single responsibility.</span></span>
- <span data-ttu-id="7f9f6-132">服务之间不存在琐碎的调用。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-132">There are no chatty calls between services.</span></span> <span data-ttu-id="7f9f6-133">如果将功能拆分成两个服务会导致它们过度琐碎，该症状的原因可能是这些功能属于同一个服务。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-133">If splitting functionality into two services causes them to be overly chatty, it may be a symptom that these functions belong in the same service.</span></span>
- <span data-ttu-id="7f9f6-134">每个服务足够小，独立工作的小团队即可构建它。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-134">Each service is small enough that it can be built by a small team working independently.</span></span>
- <span data-ttu-id="7f9f6-135">两个或更多个服务的部署不应该存在相互依赖的关系。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-135">There are no inter-dependencies that will require two or more services to be deployed in lock-step.</span></span> <span data-ttu-id="7f9f6-136">应该始终可以在不重新部署其他任何服务的情况下部署某个服务。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-136">It should always be possible to deploy a service without redeploying any other services.</span></span>
- <span data-ttu-id="7f9f6-137">服务未紧密耦合，可独立演变。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-137">Services are not tightly coupled, and can evolve independently.</span></span>
- <span data-ttu-id="7f9f6-138">服务边界不会造成数据一致性或完整性方面的问题。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-138">Your service boundaries will not create problems with data consistency or integrity.</span></span> <span data-ttu-id="7f9f6-139">有时，必须通过将功能放入单个微服务来保持数据一致性。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-139">Sometimes it's important to maintain data consistency by putting functionality into a single microservice.</span></span> <span data-ttu-id="7f9f6-140">话虽如此，但应该是否确实需要强一致性。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-140">That said, consider whether you really need strong consistency.</span></span> <span data-ttu-id="7f9f6-141">可通过某些策略来解决分布式系统中的最终一致性，分解服务的好处通常比管理最终一致性所存在的挑战更具效益。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-141">There are strategies for addressing eventual consistency in a distributed system, and the benefits of decomposing services often outweigh the challenges of managing eventual consistency.</span></span>

<span data-ttu-id="7f9f6-142">最重要的是，必须追求实用，并记住领域驱动的设计是一个迭代过程。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-142">Above all, it's important to be pragmatic, and remember that domain-driven design is an iterative process.</span></span> <span data-ttu-id="7f9f6-143">如果有疑问，可以从更粗粒度的微服务入手。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-143">When in doubt, start with more coarse-grained microservices.</span></span> <span data-ttu-id="7f9f6-144">将微服务拆分成两个较小服务比跨多个现有微服务来重构功能更方便。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-144">Splitting a microservice into two smaller services is easier than refactoring functionality across several existing microservices.</span></span>
  
## <a name="drone-delivery-defining-the-microservices"></a><span data-ttu-id="7f9f6-145">无人机交付：定义微服务</span><span class="sxs-lookup"><span data-stu-id="7f9f6-145">Drone Delivery: Defining the microservices</span></span>

<span data-ttu-id="7f9f6-146">回顾一下，前面开发团队已标识四个聚合（“交付”、“包裹”、“无人机”和“帐户”）和两个领域服务（“计划程序”和“监督程序”）。
</span><span class="sxs-lookup"><span data-stu-id="7f9f6-146">Recall that the development team had identified the four aggregates &mdash; Delivery, Package, Drone, and Account &mdash; and two domain services, Scheduler and Supervisor.</span></span> 

<span data-ttu-id="7f9f6-147">“交付”和“包裹”是微服务的突出候选项。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-147">Delivery and Package are obvious candidates for microservices.</span></span> <span data-ttu-id="7f9f6-148">“计划程序”和“监督程序”协调其他微服务执行的活动，因此，将这些领域服务实施为微服务比较有利。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-148">The Scheduler and Supervisor coordinate the activities performed by other microservices, so it makes sense to implement these domain services as microservices.</span></span>  

<span data-ttu-id="7f9f6-149">“无人机”和“帐户”比较特别，它们属于其他边界上下文。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-149">Drone and Account are interesting because they belong to other bounded contexts.</span></span> <span data-ttu-id="7f9f6-150">一种做法是让“计划程序”直接调用“无人机”和“帐户”边界上下文。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-150">One option is for the Scheduler to call the Drone and Account bounded contexts directly.</span></span> <span data-ttu-id="7f9f6-151">另一种做法是在“交货”边界上下文中创建“无人机”和“帐户”微服务。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-151">Another option is to create Drone and Account microservices inside the Shipping bounded context.</span></span> <span data-ttu-id="7f9f6-152">这些微服务通过公开更适合“交货”上下文的 API 或数据架构，在边界上下文之间充当中介。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-152">These microservices would mediate between the bounded contexts, by exposing APIs or data schemas that are more suited to the Shipping context.</span></span>

<span data-ttu-id="7f9f6-153">“无人机”和“帐户”边界上下文的详细信息超出了本指南的范畴，因此我们在参考实现中创建了它们的模拟服务。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-153">The details of the Drone and Account bounded contexts are beyond the scope of this guidance, so we created mock services for them in our reference implementation.</span></span> <span data-ttu-id="7f9f6-154">但在此情况下，需考虑一些因素：</span><span class="sxs-lookup"><span data-stu-id="7f9f6-154">But here are some factors to consider in this situation:</span></span>

- <span data-ttu-id="7f9f6-155">直接调入其他边界上下文会产生多大的网络开销？</span><span class="sxs-lookup"><span data-stu-id="7f9f6-155">What is the network overhead of calling directly into the other bounded context?</span></span> 

- <span data-ttu-id="7f9f6-156">其他边界上下文的数据架构是否适用于此上下文，或者，专门针对此边界上下文定制一个架构是否更好？</span><span class="sxs-lookup"><span data-stu-id="7f9f6-156">Is the data schema for the other bounded context suitable for this context, or is it better to have a schema that's tailored to this bounded context?</span></span> 

- <span data-ttu-id="7f9f6-157">其他边界上下文是否为旧式系统？</span><span class="sxs-lookup"><span data-stu-id="7f9f6-157">Is the other bounded context a legacy system?</span></span> <span data-ttu-id="7f9f6-158">如果是，则可以创建一个充当[防腐层](../patterns/anti-corruption-layer.md)的服务，用于在旧式系统与新式应用程序之间进行转换。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-158">If so, you might create a service that acts as an [anti-corruption layer](../patterns/anti-corruption-layer.md) to translate between the legacy system and the modern application.</span></span> 

- <span data-ttu-id="7f9f6-159">团队结构是什么？</span><span class="sxs-lookup"><span data-stu-id="7f9f6-159">What is the team structure?</span></span> <span data-ttu-id="7f9f6-160">是否能够方便地与负责其他边界上下文的团队通信？</span><span class="sxs-lookup"><span data-stu-id="7f9f6-160">Is it easy to communicate with the team that's responsible for the other bounded context?</span></span> <span data-ttu-id="7f9f6-161">如果不是，创建一个充当两个上下文之间的中介的服务可能有助于降低跨团队通信所产生的成本。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-161">If not, creating a service that mediates between the two contexts can help to mitigate the cost of cross-team communication.</span></span>

<span data-ttu-id="7f9f6-162">到目前为止，我们尚未考虑任何非功能性要求。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-162">So far, we haven't considered any non-functional requirements.</span></span> <span data-ttu-id="7f9f6-163">考虑到应用程序的吞吐量要求，开发团队决定创建一个负责引入客户端请求的独立“引入”微服务。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-163">Thinking about the application's throughput requirements, the development team decided to create a separate Ingestion microservice that is responsible for ingesting client requests.</span></span> <span data-ttu-id="7f9f6-164">此微服务将传入的请求放入缓冲区进行处理，以此实施[负载调节](../patterns/queue-based-load-leveling.md)。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-164">This microservice will implement [load leveling](../patterns/queue-based-load-leveling.md) by putting incoming requests into a buffer for processing.</span></span> <span data-ttu-id="7f9f6-165">计划程序将从缓冲区读取请求，并执行工作流。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-165">The Scheduler will read the requests from the buffer and execute the workflow.</span></span> 

<span data-ttu-id="7f9f6-166">非功能性要求使得团队必须额外创建一个服务。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-166">Non-functional requirements led the team to create one additional service.</span></span> <span data-ttu-id="7f9f6-167">到目前为止，所有服务都与包裹的实时安排和交付过程相关。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-167">All of the services so far have been about the process of scheduling and delivering packages in real time.</span></span> <span data-ttu-id="7f9f6-168">但是，系统还需要在长期存储中存储每项交付的历史记录，以进行数据分析。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-168">But the system also needs to store the history of every delivery in long-term storage for data analysis.</span></span> <span data-ttu-id="7f9f6-169">团队认为这是交付服务的责任。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-169">The team considered making this the responsibility of the Delivery service.</span></span> <span data-ttu-id="7f9f6-170">但是，历史分析与现行操作的数据存储要求有较大的差别（请参阅[数据注意事项](./data-considerations.md)）。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-170">However, the data storage requirements are quite different for historical analysis versus in-flight operations (see [Data considerations](./data-considerations.md)).</span></span> <span data-ttu-id="7f9f6-171">因此，团队决定创建一个独立的交付历史记录服务，用于侦听来自交付服务的 DeliveryTracking 事件，并将这些事件写入长期存储。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-171">Therefore, the team decided to create a separate Delivery History service, which will listen for DeliveryTracking events from the Delivery service and write the events into long-term storage.</span></span>

<span data-ttu-id="7f9f6-172">下图展示了现阶段的设计：</span><span class="sxs-lookup"><span data-stu-id="7f9f6-172">The following diagram shows the design at this point:</span></span>
 
![](./images/microservices.png)

## <a name="choosing-a-compute-option"></a><span data-ttu-id="7f9f6-173">选择计算选项</span><span class="sxs-lookup"><span data-stu-id="7f9f6-173">Choosing a compute option</span></span>

<span data-ttu-id="7f9f6-174">术语“计算”指的是计算资源（应用程序在这些资源上运行）的承载模型。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-174">The term *compute* refers to the hosting model for the computing resources that your application runs on.</span></span> <span data-ttu-id="7f9f6-175">在微服务体系结构方面，有两种方案特别流行：</span><span class="sxs-lookup"><span data-stu-id="7f9f6-175">For a microservices architecture, two approaches are especially popular:</span></span>

- <span data-ttu-id="7f9f6-176">可管理专用节点 (VM) 上运行的服务的服务业务流程协调程序。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-176">A service orchestrator that manages services running on dedicated nodes (VMs).</span></span>
- <span data-ttu-id="7f9f6-177">使用函数即服务 (FaaS) 的无服务器体系结构。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-177">A serverless architecture using functions as a service (FaaS).</span></span> 

<span data-ttu-id="7f9f6-178">尽管这不是仅有的两个选项，但两者是用于构建微服务的成熟方案。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-178">While these aren't the only options, they are both proven approaches to building microservices.</span></span> <span data-ttu-id="7f9f6-179">应用程序可以包含这两种方案。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-179">An application might include both approaches.</span></span>

### <a name="service-orchestrators"></a><span data-ttu-id="7f9f6-180">服务业务流程协调程序</span><span class="sxs-lookup"><span data-stu-id="7f9f6-180">Service orchestrators</span></span>

<span data-ttu-id="7f9f6-181">业务流程协调程序处理与一组服务的部署和管理相关的任务。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-181">An orchestrator handles tasks related to deploying and managing a set of services.</span></span> <span data-ttu-id="7f9f6-182">这些任务包括在节点上放置服务、监视服务运行状况、重启不正常的服务、对服务实例之间的网络流量进行负载均衡、服务发现、缩放服务实例的数目，以及应用配置更新。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-182">These tasks include placing services on nodes, monitoring the health of services, restarting unhealthy services, load balancing network traffic across service instances, service discovery, scaling the number of instances of a service, and applying configuration updates.</span></span> <span data-ttu-id="7f9f6-183">流行的业务流程协调程序包括 Kubernetes、DC/OS、Docker Swarm 和 Service Fabric。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-183">Popular orchestrators include Kubernetes, DC/OS, Docker Swarm, and Service Fabric.</span></span> 

- <span data-ttu-id="7f9f6-184">[Azure 容器服务](/azure/container-service/) (ACS) 是一个 Azure 服务，可用于部署随时可投入生产的 Kubernetes、DC/OS 或 Docker Swarm 群集。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-184">[Azure Container Service](/azure/container-service/) (ACS) is an Azure service that lets you deploy a production-ready Kubernetes, DC/OS, or Docker Swarm cluster.</span></span>

- <span data-ttu-id="7f9f6-185">[AKS（Azure 容器服务）](/azure/aks/)是托管的 Kubernetes 服务。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-185">[AKS (Azure Container Service)](/azure/aks/) is a managed Kubernetes service.</span></span> <span data-ttu-id="7f9f6-186">AKS 预配 Kubernetes 并公开 Kubernetes API 终结点，但可以承载和管理 Kubernetes 控制平面，并可以执行自动升级、自动修补、自动缩放和其他管理任务。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-186">AKS provisions Kubernetes and exposes the Kubernetes API endpoints, but hosts and manages the Kubernetes control plane, performing automated upgrades, automated patching, autoscaling, and other management tasks.</span></span> <span data-ttu-id="7f9f6-187">可将 AKS 视为“Kubernetes API 即服务”。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-187">You can think of AKS as being "Kubernetes APIs as a service."</span></span> <span data-ttu-id="7f9f6-188">在撰写本文时，AKS 仍为预览版。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-188">At the time of writing, AKS is still in preview.</span></span> <span data-ttu-id="7f9f6-189">但是，AKS 有望成为在 Azure 中运行 Kubernetes 的首选方法。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-189">However, it's expected that AKS will become the preferred way to run Kubernetes in Azure.</span></span> 

- <span data-ttu-id="7f9f6-190">[Service Fabric](/azure/service-fabric/) 是用于打包、部署和管理微服务的分布式系统平台。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-190">[Service Fabric](/azure/service-fabric/) is a distributed systems platform for packaging, deploying, and managing microservices.</span></span> <span data-ttu-id="7f9f6-191">可将微服务作为容器、二进制可执行文件或 [Reliable Services](/azure/service-fabric/service-fabric-reliable-services-introduction) 部署到 Service Fabric。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-191">Microservices can be deployed to Service Fabric as containers, as binary executables, or as [Reliable Services](/azure/service-fabric/service-fabric-reliable-services-introduction).</span></span> <span data-ttu-id="7f9f6-192">借助 Reliable Services 编程模型，服务可以直接使用 Service Fabric 编程 API 来查询系统、报告运行状况、接收有关配置和代码更改的通知，以及发现其他服务。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-192">Using the Reliable Services programming model, services can directly use Service Fabric programming APIs to query the system, report health, receive notifications about configuration and code changes, and discover other services.</span></span> <span data-ttu-id="7f9f6-193">它与 Service Fabric 之间的重要区别在于，它重点用于构建使用 [Reliable Collections](/azure/service-fabric/service-fabric-reliable-services-reliable-collections) 的有状态服务。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-193">A key differentiation with Service Fabric is its strong focus on building stateful services using [Reliable Collections](/azure/service-fabric/service-fabric-reliable-services-reliable-collections).</span></span>

### <a name="containers"></a><span data-ttu-id="7f9f6-194">容器</span><span class="sxs-lookup"><span data-stu-id="7f9f6-194">Containers</span></span>

<span data-ttu-id="7f9f6-195">有时，人们在谈论容器和微服务时将它们看作相同的事物。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-195">Sometimes people talk about containers and microservices as if they were the same thing.</span></span> <span data-ttu-id="7f9f6-196">尽管这种看法不对 &mdash; 不需要容器即可构建微服务 &mdash; 但是，容器确实有一些专门与微服务相关的优势，例如：</span><span class="sxs-lookup"><span data-stu-id="7f9f6-196">While that's not true &mdash; you don't need containers to build microservices &mdash; containers do have some benefits that are particularly relevant to microservices, such as:</span></span>

- <span data-ttu-id="7f9f6-197">**可移植性**。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-197">**Portability**.</span></span> <span data-ttu-id="7f9f6-198">容器映像是一个独立包，无需安装库或其他依赖项即可运行。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-198">A container image is a standalone package that runs without needing to install libraries or other dependencies.</span></span> <span data-ttu-id="7f9f6-199">因此，它们的部署非常轻松。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-199">That makes them easy to deploy.</span></span> <span data-ttu-id="7f9f6-200">容器可以快速启动和停止，因此，我们可以运转新的实例来处理更多负载，或者在发生节点故障后进行恢复。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-200">Containers can be started and stopped quickly, so you can spin up new instances to handle more load or to recover from node failures.</span></span> 

- <span data-ttu-id="7f9f6-201">**轻量且高效**。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-201">**Density**.</span></span> <span data-ttu-id="7f9f6-202">与运行虚拟机相比，容器比较轻量，因为它们共享 OS 资源。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-202">Containers are lightweight compared with running a virtual machine, because they share OS resources.</span></span> <span data-ttu-id="7f9f6-203">因此，可将多个容器打包到单个节点。当应用程序由许多小型服务构成时，这种做法特别有利。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-203">That makes it possible to pack multiple containers onto a single node, which is especially useful when the application consists of many small services.</span></span>

- <span data-ttu-id="7f9f6-204">**资源隔离**。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-204">**Resource isolation**.</span></span> <span data-ttu-id="7f9f6-205">可以限制容器可用的内存量和 CPU，这有助于确保失控的进程不会耗尽主机资源。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-205">You can limit the amount of memory and CPU that is available to a container, which can help to ensure that a runaway process doesn't exhaust the host resources.</span></span> <span data-ttu-id="7f9f6-206">有关详细信息，请参阅[隔舱模式](../patterns/bulkhead.md)。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-206">See the [Bulkhead Pattern](../patterns/bulkhead.md) for more information.</span></span>

### <a name="serverless-functions-as-a-service"></a><span data-ttu-id="7f9f6-207">无服务器（函数即服务）</span><span class="sxs-lookup"><span data-stu-id="7f9f6-207">Serverless (Functions as a Service)</span></span>

<span data-ttu-id="7f9f6-208">使用无服务器体系结构时，无需管理 VM 或虚拟网络基础结构。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-208">With a serverless architecture, you don't manage the VMs or the virtual network infrastructure.</span></span> <span data-ttu-id="7f9f6-209">可以部署代码，然后让托管服务将该代码放入 VM 并执行。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-209">Instead, you deploy code and the hosting service handles putting that code onto a VM and executing it.</span></span> <span data-ttu-id="7f9f6-210">这种方法往往比较适合用于使用基于事件的触发器协调的小粒度函数。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-210">This approach tends to favor small granular functions that are coordinated using event-based triggers.</span></span> <span data-ttu-id="7f9f6-211">例如，放入队列的消息可能会触发一个函数，该函数从队列中读取并处理该消息。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-211">For example, a message being placed onto a queue might trigger a function that reads from the queue and processes the message.</span></span>

<span data-ttu-id="7f9f6-212">[Azure Functions][functions] 是支持各种函数触发器（包括 HTTP 请求、服务总线队列和事件中心事件）的无服务器计算服务。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-212">[Azure Functions][functions] is a serverless compute service that supports various function triggers, including HTTP requests, Service Bus queues, and Event Hubs events.</span></span> <span data-ttu-id="7f9f6-213">有关完整列表，请参阅 [Azure Functions 触发器和绑定概念][functions-triggers]。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-213">For a complete list, see [Azure Functions triggers and bindings concepts][functions-triggers].</span></span> <span data-ttu-id="7f9f6-214">另请考虑 [Azure 事件网格][event-grid]，它是 Azure 中的托管事件路由服务。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-214">Also consider [Azure Event Grid][event-grid], which is a managed event routing service in Azure.</span></span>

### <a name="orchestrator-or-serverless"></a><span data-ttu-id="7f9f6-215">选择业务流程协调程序还是无服务器？</span><span class="sxs-lookup"><span data-stu-id="7f9f6-215">Orchestrator or serverless?</span></span>

<span data-ttu-id="7f9f6-216">在业务流程协调程序方案与无服务器方案之间做出选择时，请考虑下面一些因素。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-216">Here are some factors to consider when choosing between an orchestrator approach and a serverless approach.</span></span>

<span data-ttu-id="7f9f6-217">**易管理性**无服务器应用程序易于管理，因为平台可自行管理所有计算资源。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-217">**Manageability** A serverless application is easy to manage, because the platform manages all the of compute resources for you.</span></span> <span data-ttu-id="7f9f6-218">尽管业务流程协调程序可将群集管理和配置工作的某些方面抽象化，但它不会完全隐藏底层 VM。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-218">While an orchestrator abstracts some aspects of managing and configuring a cluster, it does not completely hide the underlying VMs.</span></span> <span data-ttu-id="7f9f6-219">使用业务流程协调程序时，需要考虑负载均衡、CPU 和内存使用率以及网络等方面的问题。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-219">With an orchestrator, you will need to think about issues such as load balancing, CPU and memory usage, and networking.</span></span>

<span data-ttu-id="7f9f6-220">**灵活性和控制**。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-220">**Flexibility and control**.</span></span> <span data-ttu-id="7f9f6-221">在服务与群集的配置和管理方面，业务流程协调程序提供很高的控制度。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-221">An orchestrator gives you a great deal of control over configuring and managing your services and the cluster.</span></span> <span data-ttu-id="7f9f6-222">弊端是复杂性会增大。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-222">The tradeoff is additional complexity.</span></span> <span data-ttu-id="7f9f6-223">使用无服务器体系结构会牺牲一定的控制度，因为这些细节已抽象化。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-223">With a serverless architecture, you give up some degree of control because these details are abstracted.</span></span>

<span data-ttu-id="7f9f6-224">**可移植性**。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-224">**Portability**.</span></span> <span data-ttu-id="7f9f6-225">此处列出的所有业务流程协调程序（Kubernetes、DC/OS、Docker Swarm 和 Service Fabric）都可以在本地或多个公有云中运行。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-225">All of the orchestrators listed here (Kubernetes, DC/OS, Docker Swarm, and Service Fabric) can run on-premises or in multiple public clouds.</span></span> 

<span data-ttu-id="7f9f6-226">**应用程序集成**。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-226">**Application integration**.</span></span> <span data-ttu-id="7f9f6-227">使用无服务器体系结构构建复杂应用程序可能有难度。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-227">It can be challenging to build a complex application using a serverless architecture.</span></span> <span data-ttu-id="7f9f6-228">在 Azure 中，一种做法是使用 [Azure 逻辑应用](/azure/logic-apps/)来协调一组 Azure 函数。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-228">One option in Azure is to use [Azure Logic Apps](/azure/logic-apps/) to coordinate a set of Azure Functions.</span></span> <span data-ttu-id="7f9f6-229">有关此方法的示例，请参阅[创建与 Azure 逻辑应用集成的函数](/azure/azure-functions/functions-twitter-email)。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-229">For an example of this approach, see [Create a function that integrates with Azure Logic Apps](/azure/azure-functions/functions-twitter-email).</span></span>

<span data-ttu-id="7f9f6-230">**成本**。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-230">**Cost**.</span></span> <span data-ttu-id="7f9f6-231">使用业务流程协调程序时，需要为群集中运行的 VM 付费。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-231">With an orchestrator, you pay for the VMs that are running in the cluster.</span></span> <span data-ttu-id="7f9f6-232">使用无服务器应用程序时，只需为实际消耗的计算资源付费。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-232">With a serverless application, you pay only for the actual compute resources consumed.</span></span> <span data-ttu-id="7f9f6-233">在这两种情况下，都需要考虑到任何附加服务（例如存储、数据库和消息传递服务）的成本。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-233">In both cases, you need to factor in the cost of any additional services, such as storage, databases, and messaging services.</span></span>

<span data-ttu-id="7f9f6-234">**可伸缩性**。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-234">**Scalability**.</span></span> <span data-ttu-id="7f9f6-235">Azure Functions 可以根据传入事件的数目按需自动缩放。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-235">Azure Functions scales automatically to meet demand, based on the number of incoming events.</span></span> <span data-ttu-id="7f9f6-236">使用业务流程协调程序时，可以通过增加群集中运行的服务实例数进行横向扩展。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-236">With an orchestrator, you can scale out by increasing the number of service instances running in the cluster.</span></span> <span data-ttu-id="7f9f6-237">此外，可以通过将更多 VM 添加到群集进行扩展。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-237">You can also scale by adding additional VMs to the cluster.</span></span>

<span data-ttu-id="7f9f6-238">我们的参考实现主要使用 Kubernetes，但对“交付历史记录”服务使用了 Azure Functions。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-238">Our reference implementation primarily uses Kubernetes, but we did use Azure Functions for one service, namely the Delivery History service.</span></span> <span data-ttu-id="7f9f6-239">Azure Functions 非常适合此特定服务，因为它是事件驱动的工作负荷。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-239">Azure Functions was a good fit for this particular service, because it's is an event-driven workload.</span></span> <span data-ttu-id="7f9f6-240">该服务使用事件中心触发器来调用函数，因此只需少量的代码。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-240">By using an Event Hubs trigger to invoke the function, the service needed a minimal amount of code.</span></span> <span data-ttu-id="7f9f6-241">此外，“交付历史记录”服务并非主要工作流的一部分，因此，在 Kubernetes 群集外部运行该服务不会影响用户发起的操作的端到端延迟。</span><span class="sxs-lookup"><span data-stu-id="7f9f6-241">Also, the Delivery History service is not part of the main workflow, so running it outside of the Kubernetes cluster doesn't affect the end-to-end latency of user-initiated operations.</span></span> 

> [!div class="nextstepaction"]
> [<span data-ttu-id="7f9f6-242">数据注意事项</span><span class="sxs-lookup"><span data-stu-id="7f9f6-242">Data considerations</span></span>](./data-considerations.md)

<!-- links -->

[acs-engine]: https://github.com/Azure/acs-engine
[acs-faq]: /azure/container-service/dcos-swarm/container-service-faq
[event-grid]: /azure/event-grid/
[functions]: /azure/azure-functions/functions-overview
[functions-triggers]: /azure/azure-functions/functions-triggers-bindings
