---
title: "微服务的数据注意事项"
description: "微服务的数据注意事项"
author: MikeWasson
ms.date: 12/08/2017
ms.openlocfilehash: 9bd7a8424309b5753b42cfb70559836288a3ce9d
ms.sourcegitcommit: c7f46b14ad7d55cf553b2d0b01045c9c25aefcdb
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/09/2017
---
# <a name="designing-microservices-data-considerations"></a><span data-ttu-id="c6f6b-103">设计微服务：数据注意事项</span><span class="sxs-lookup"><span data-stu-id="c6f6b-103">Designing microservices: Data considerations</span></span>

<span data-ttu-id="c6f6b-104">本章介绍在微服务体系结构中管理数据时的注意事项。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-104">This chapter describes considerations for managing data in a microservices architecture.</span></span> <span data-ttu-id="c6f6b-105">由于每个微服务管理自身的数据，因此，数据完整性和数据一致性是关键的挑战。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-105">Because every microservice manages its own data, data integrity and data consistency are critical challenges.</span></span>

![](./images/data-considerations.png)

<span data-ttu-id="c6f6b-106">微服务的基本原则是每个服务管理其自身的数据。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-106">A basic principle of microservices is that each service manages its own data.</span></span> <span data-ttu-id="c6f6b-107">两个服务不应共享数据存储。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-107">Two services should not share a data store.</span></span> <span data-ttu-id="c6f6b-108">相反，每个服务负责管理维护自身的专用数据存储，其他服务不能直接访问该存储。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-108">Instead, each service is responsible for its own private data store, which other services cannot access directly.</span></span>

<span data-ttu-id="c6f6b-109">制定此规则的原因是避免服务之间出现意外耦合 - 如果服务共享相同的基础数据架构，就会出现这种情况。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-109">The reason for this rule is to avoid unintentional coupling between services, which can result if services share the same underlying data schemas.</span></span> <span data-ttu-id="c6f6b-110">如果对数据架构做了某项更改，必须在依赖于该数据库的每个服务之间协调该项更改。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-110">If there is a change to the data schema, the change must be coordinated across every service that relies on that database.</span></span> <span data-ttu-id="c6f6b-111">通过隔离每个服务的数据存储，我们可以限制更改范围，并保持真正独立部署的灵活性。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-111">By isolating each service's data store, we can limit the scope of change, and preserve the agility of truly independent deployments.</span></span> <span data-ttu-id="c6f6b-112">另一个原因是，每个微服务可能有自身的数据模型、查询或读/写模式。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-112">Another reason is that each microservice may have its own data models, queries, or read/write patterns.</span></span> <span data-ttu-id="c6f6b-113">使用共享的数据存储会限制每个团队为其特定服务优化数据存储的能力。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-113">Using a shared data store limits each team's ability to optimize data storage for their particular service.</span></span> 

![](../guide/architecture-styles/images/cqrs-microservices-wrong.png)

<span data-ttu-id="c6f6b-114">这种做法自然而然会导致 [Polyglot 持久性](https://martinfowler.com/bliki/PolyglotPersistence.html) &mdash; 在单个应用程序中使用多种数据存储技术。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-114">This approach naturally leads to [polyglot persistence](https://martinfowler.com/bliki/PolyglotPersistence.html) &mdash; the use of multiple data storage technologies within a single application.</span></span> <span data-ttu-id="c6f6b-115">一个服务可能需要文档数据库的“读时架构”功能。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-115">One service might require the schema-on-read capabilities of a document database.</span></span> <span data-ttu-id="c6f6b-116">另一个服务可能需要 RDBMS 提供的引用完整性。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-116">Another might need the referential integrity provided by an RDBMS.</span></span> <span data-ttu-id="c6f6b-117">每个团队可以根据其服务任意做出最佳选择。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-117">Each team is free to make the best choice for their service.</span></span> <span data-ttu-id="c6f6b-118">有关 Polyglot 持久性一般原则的详细信息，请参阅[使用最佳的数据存储完成作业](../guide/design-principles/use-the-best-data-store.md)。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-118">For more about the general principle of polyglot persistence, see [Use the best data store for the job](../guide/design-principles/use-the-best-data-store.md).</span></span> 

> [!NOTE]
> <span data-ttu-id="c6f6b-119">服务可以共享相同的物理数据库服务器。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-119">It's fine for services to share the same physical database server.</span></span> <span data-ttu-id="c6f6b-120">当服务共享相同的架构或者在相同的数据库表集中读取和写入数据时，就会出现问题。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-120">The problem occurs when services share the same schema, or read and write to the same set of database tables.</span></span>


## <a name="challenges"></a><span data-ttu-id="c6f6b-121">挑战</span><span class="sxs-lookup"><span data-stu-id="c6f6b-121">Challenges</span></span>

<span data-ttu-id="c6f6b-122">这种分布式数据管理方法存在一些挑战。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-122">Some challenges arise from this distributed approach to managing data.</span></span> <span data-ttu-id="c6f6b-123">首先，数据存储之间可能出现冗余，即同一个数据项显示在多个位置。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-123">First, there may be redundancy across the data stores, with the same item of data appearing in multiple places.</span></span> <span data-ttu-id="c6f6b-124">例如，数据一开始存储为事务的一部分，然后又存储在其他位置供分析、报告或存档。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-124">For example, data might be stored as part of a transaction, then stored elsewhere for analytics, reporting, or archiving.</span></span> <span data-ttu-id="c6f6b-125">重复或分区的数据可能导致数据完整性和一致性问题。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-125">Duplicated or partitioned data can lead to issues of data integrity and consistency.</span></span> <span data-ttu-id="c6f6b-126">当数据关系跨越多个服务时，无法使用传统的数据管理方法来实施关系。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-126">When data relationships span multiple services, you can't use traditional data management techniques to enforce the relationships.</span></span>

<span data-ttu-id="c6f6b-127">传统数据建模使用“一个位置一个事实”的规则。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-127">Traditional data modeling uses the rule of "one fact in one place."</span></span> <span data-ttu-id="c6f6b-128">每个实体只在架构中出现一次。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-128">Every entity appears exactly once in the schema.</span></span> <span data-ttu-id="c6f6b-129">其他实体可以保留对该实体的引用，但不能复制它。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-129">Other entities may hold references to it but not duplicate it.</span></span> <span data-ttu-id="c6f6b-130">传统方法的明显优势是在一个位置进行更新，从而可以避免数据一致性问题。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-130">The obvious advantage to the traditional approach is that updates are made in a single place, which avoids problems with data consistency.</span></span> <span data-ttu-id="c6f6b-131">在微服务体系结构中，必须考虑如何在服务之间传播更新，以及在未实施强一致性的情况下，如果数据出现在多个位置，应如何管理最终一致性。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-131">In a microservices architecture, you have to consider how updates are propagated across services, and how to manage eventual consistency when data appears in multiple places without strong consistency.</span></span> 

## <a name="approaches-to-managing-data"></a><span data-ttu-id="c6f6b-132">数据管理方法</span><span class="sxs-lookup"><span data-stu-id="c6f6b-132">Approaches to managing data</span></span>

<span data-ttu-id="c6f6b-133">不存在以一应百的方法，不过，在微服务体系结构中管理数据时，可以遵循一些通用准则。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-133">There is no single approach that's correct in all cases, but here are some general guidelines for managing data in a microservices architecture.</span></span>

- <span data-ttu-id="c6f6b-134">如果可能，请采用最终一致性。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-134">Embrace eventual consistency where possible.</span></span> <span data-ttu-id="c6f6b-135">了解系统中需要强一致性或 ACID 事务的位置，以及可接受最终一致性的位置。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-135">Understand the places in the system where you need strong consistency or ACID transactions, and the places where eventual consistency is acceptable.</span></span>

- <span data-ttu-id="c6f6b-136">需要强一致性保证时，一个服务可以代表给定实体的事实源（通过 API 公开）。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-136">When you need strong consistency guarantees, one service may represent the source of truth for a given entity, which is exposed through an API.</span></span> <span data-ttu-id="c6f6b-137">其他服务可以保留自身的数据副本或数据子集，这些数据与主数据最终保持一致，但不被视为事实源。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-137">Other services might hold their own copy of the data, or a subset of the data, that is eventually consistent with the master data but not considered the source of truth.</span></span> <span data-ttu-id="c6f6b-138">例如，假设有一个包含客户订单服务和推荐服务的电子商务系统。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-138">For example, imagine an e-commerce system with a customer order service and a recommendation service.</span></span> <span data-ttu-id="c6f6b-139">推荐服务可以侦听来自订单服务的事件，但如果客户请求退款，则只有订单服务包含完整的交易历史记录，而推荐服务则没有此类信息。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-139">The recommendation service might listen to events from the order service, but if a customer requests a refund, it is the order service, not the recommendation service, that has the complete transaction history.</span></span>

- <span data-ttu-id="c6f6b-140">对于事务，可以使用[计划程序代理监督程序](../patterns/scheduler-agent-supervisor.md)和[补偿事务](../patterns/compensating-transaction.md)等模式来保持多个服务之间的数据一致性。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-140">For transactions, use patterns such as [Scheduler Agent Supervisor](../patterns/scheduler-agent-supervisor.md) and [Compensating Transaction](../patterns/compensating-transaction.md) to keep data consistent across several services.</span></span>  <span data-ttu-id="c6f6b-141">可能需要存储附加的数据片段用于捕获跨多个服务的工作单元的状态，以免多个服务之间发生部分失败。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-141">You may need to store an additional piece of data that captures the state of a unit of work that spans multiple services, to avoid partial failure among multiple services.</span></span> <span data-ttu-id="c6f6b-142">例如，在处理多步骤事务的过程中，可将某个工作项保留在持久队列中。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-142">For example, keep a work item on a durable queue while a multi-step transaction is in progress.</span></span> 

- <span data-ttu-id="c6f6b-143">只存储服务所需的数据。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-143">Store only the data that a service needs.</span></span> <span data-ttu-id="c6f6b-144">服务可能只需要有关域实体的一部分信息。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-144">A service might only need a subset of information about a domain entity.</span></span> <span data-ttu-id="c6f6b-145">例如，在“交货”边界上下文中，我们需要知道哪个客户已关联到特定的交付项。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-145">For example, in the Shipping bounded context, we need to know which customer is associated to a particular delivery.</span></span> <span data-ttu-id="c6f6b-146">但是，我们不需要客户的帐单地址 &mdash; 该信息由“帐户”边界上下文管理。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-146">But we don't need the customer's billing address &mdash; that's managed by the Accounts bounded context.</span></span> <span data-ttu-id="c6f6b-147">在此情况下，认真考虑域的要求并使用 DDD 方法可能有所帮助。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-147">Thinking carefully about the domain, and using a DDD approach, can help here.</span></span> 

- <span data-ttu-id="c6f6b-148">考虑服务是否是内聚且松散耦合的。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-148">Consider whether your services are coherent and loosely coupled.</span></span> <span data-ttu-id="c6f6b-149">如果两个服务持续相互交换信息，导致出现琐碎 API，则你可能需要通过合并两个服务或重构其功能来重绘服务边界。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-149">If two services are continually exchanging information with each other, resulting in chatty APIs, you may need to redraw your service boundaries, by merging two services or refactoring their functionality.</span></span>

- <span data-ttu-id="c6f6b-150">使用[事件驱动的体系结构样式](../guide/architecture-styles/event-driven.md)。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-150">Use an [event driven architecture style](../guide/architecture-styles/event-driven.md).</span></span> <span data-ttu-id="c6f6b-151">在此体系结构样式中，当某个服务的公共模型或实体发生更改时，该服务会发布事件。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-151">In this architecture style, a service publishes an event when there are changes to its public models or entities.</span></span> <span data-ttu-id="c6f6b-152">相关的服务可以订阅这些事件。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-152">Interested services can subscribe to these events.</span></span> <span data-ttu-id="c6f6b-153">例如，另一个服务可以使用事件来构造更适合用于查询的具体化数据视图。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-153">For example, another service could use the events to construct a materialized view of the data that is more suitable for querying.</span></span> 

- <span data-ttu-id="c6f6b-154">拥有事件的服务应发布可用于自动序列化和反序列化事件的架构，以免发布方与订阅方之间发生紧密耦合。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-154">A service that owns events should publish a schema that can be used to automate serializing and deserializing the events, to avoid tight coupling between publishers and subscribers.</span></span> <span data-ttu-id="c6f6b-155">考虑使用 JSON 架构，或者 [Microsoft Bond](https://github.com/Microsoft/bond)、Protobuf 或 Avro 等框架。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-155">Consider JSON schema or a framework like [Microsoft Bond](https://github.com/Microsoft/bond), Protobuf, or Avro.</span></span>  
 
- <span data-ttu-id="c6f6b-156">在大规模运营中，事件可能成为系统中的瓶颈，因此，请考虑使用聚合或批处理来减少总负载。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-156">At high scale, events can become a bottleneck on the system, so consider using aggregation or batching to reduce the total load.</span></span> 

## <a name="drone-delivery-choosing-the-data-stores"></a><span data-ttu-id="c6f6b-157">无人机交付：选择数据存储</span><span class="sxs-lookup"><span data-stu-id="c6f6b-157">Drone Delivery: Choosing the data stores</span></span> 

<span data-ttu-id="c6f6b-158">尽管只包含少量的几个服务，但“交货”边界上下文仍然演示了本部分中所述的要点。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-158">Even with only a few services, the Shipping bounded context illustrates several of the points discussed in this section.</span></span> 

<span data-ttu-id="c6f6b-159">当用户安排新的交付时，客户端请求中将会包含有关交付的信息（例如收件和投递地点）和有关包裹的信息（例如大小与重量）。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-159">When a user schedules a new delivery, the client request includes information about the both the delivery, such as the pickup and dropoff locations, and about the package, such as the size and weight.</span></span> <span data-ttu-id="c6f6b-160">此信息定义工作单位，引入服务会将其发送到事件中心。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-160">This information defines a unit of work, which the Ingestion service sends to Event Hubs.</span></span> <span data-ttu-id="c6f6b-161">当计划程序服务执行工作流时，该工作单位必须保留在持久性存储中，以便不会丢失交付请求。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-161">It's important that the unit of work stays in persistent storage while the Scheduler service is executing the workflow, so that no delivery requests are lost.</span></span> <span data-ttu-id="c6f6b-162">有关工作流的更多讨论，请参阅[引入和工作流](./ingestion-workflow.md)。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-162">For more discussion of the workflow, see [Ingestion and workflow](./ingestion-workflow.md).</span></span> 

<span data-ttu-id="c6f6b-163">各种后端服务将会处理请求中的不同信息部分，并且包含不同的读取和写入配置文件。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-163">The various backend services care about different portions of the information in the request, and also have different read and write profiles.</span></span> 

### <a name="delivery-service"></a><span data-ttu-id="c6f6b-164">交付服务</span><span class="sxs-lookup"><span data-stu-id="c6f6b-164">Delivery service</span></span>

<span data-ttu-id="c6f6b-165">交付服务存储有关当前已安排的或正在处理的每项交付的信息。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-165">The Delivery service stores information about every delivery that is currently scheduled or in progress.</span></span> <span data-ttu-id="c6f6b-166">它会侦听来自无人机的事件，并跟踪正在进行的交付的状态。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-166">It listens for events from the drones, and tracks the status of deliveries that are in progress.</span></span> <span data-ttu-id="c6f6b-167">此外，它会发送包含交付状态更新内容的域事件。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-167">It also sends domain events with delivery status updates.</span></span>

<span data-ttu-id="c6f6b-168">用户在等待包裹期间，预期会经常检查交付状态。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-168">It's expected that users will frequently check the status of a delivery while they are waiting for their package.</span></span> <span data-ttu-id="c6f6b-169">因此，交付服务需要一个具有突出吞吐量（读取和写入）而不是持久性的数据存储。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-169">Therefore, the Delivery service requires a data store that emphasizes throughput (read and write) over long-term storage.</span></span> <span data-ttu-id="c6f6b-170">此外，交付服务不会执行任何复杂的查询或分析，而只是提取给定交付的最新状态。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-170">Also, the Delivery service does not perform any complex queries or analysis, it simply fetches the latest status for a given delivery.</span></span> <span data-ttu-id="c6f6b-171">交付服务团队可以选择 Azure Redis 缓存来提高读写性能。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-171">The Delivery service team chose Azure Redis Cache for its high read-write performance.</span></span> <span data-ttu-id="c6f6b-172">Redis 中存储的信息的生存期相对较短。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-172">The information stored in Redis is relatively short-lived.</span></span> <span data-ttu-id="c6f6b-173">交付完成后，交付历史记录服务即是记录系统。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-173">Once a delivery is complete, the Delivery History service is the system of record.</span></span>

### <a name="delivery-history-service"></a><span data-ttu-id="c6f6b-174">交付历史记录服务</span><span class="sxs-lookup"><span data-stu-id="c6f6b-174">Delivery History service</span></span>

<span data-ttu-id="c6f6b-175">交付历史记录服务侦听来自交付服务的交付状态事件。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-175">The Delivery History service listens for delivery status events from the Delivery service.</span></span> <span data-ttu-id="c6f6b-176">它将此数据存储在长期存储中。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-176">It stores this data in long-term storage.</span></span> <span data-ttu-id="c6f6b-177">此历史数据有两种不同的用例，每种用例有不同的数据存储要求。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-177">There are two different use-cases for this historical data, which have different data storage requirements.</span></span> 

<span data-ttu-id="c6f6b-178">第一种方案是聚合用于数据分析的数据，以优化业务或改进服务质量。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-178">The first scenario is aggregating the data for the purpose of data analytics, in order to optimize the business or improve the quality of the service.</span></span> <span data-ttu-id="c6f6b-179">请注意，交付历史记录服务不执行实际的数据分析。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-179">Note that the Delivery History service doesn't perform the actual analysis of the data.</span></span> <span data-ttu-id="c6f6b-180">它只是负责引入和存储。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-180">It's only responsible for the ingestion and storage.</span></span> <span data-ttu-id="c6f6b-181">对于此方案，必须优化存储以针对大量数据执行数据分析，并使用“读时架构”方法来适应各种数据源。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-181">For this scenario, the storage must be optimized for data analysis over a large set of data, using a schema-on-read approach to accommodate a variety of data sources.</span></span> <span data-ttu-id="c6f6b-182">[Azure Data Lake Store](/azure/data-lake-store/) 非常适合此方案。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-182">[Azure Data Lake Store](/azure/data-lake-store/) is a good fit for this scenario.</span></span> <span data-ttu-id="c6f6b-183">Data Lake Store 是与 Hadoop 分布式文件系统 (HDFS) 兼容的 Apache Hadoop 文件系统，已针对数据分析方案的性能进行优化。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-183">Data Lake Store is an Apache Hadoop file system compatible with Hadoop Distributed File System (HDFS), and is tuned for performance for data analytics scenarios.</span></span> 

<span data-ttu-id="c6f6b-184">另一种方案是在完成交付后，让用户查找交付历史记录。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-184">The other scenario is enabling users to look up the history of a delivery after the delivery is completed.</span></span> <span data-ttu-id="c6f6b-185">Azure Data Lake 并未专门针对此方案进行优化。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-185">Azure Data Lake is not particularly optimized for this scenario.</span></span> <span data-ttu-id="c6f6b-186">为获得最佳性能，Microsoft 建议将时序数据存储在 Data Lake 中已按日期分区的文件夹内。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-186">For optimal performance, Microsoft recommends storing time-series data in Data Lake in folders partitioned by date.</span></span> <span data-ttu-id="c6f6b-187">（请参阅[优化 Azure Data Lake Store 性能](/azure/data-lake-store/data-lake-store-performance-tuning-guidance)）。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-187">(See [Tuning Azure Data Lake Store for performance](/azure/data-lake-store/data-lake-store-performance-tuning-guidance)).</span></span> <span data-ttu-id="c6f6b-188">但是，在按 ID 查找单个记录时，该结构并不是最佳的。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-188">However, that structure is not optimal for looking up individual records by ID.</span></span> <span data-ttu-id="c6f6b-189">除非同时知道时间戳，否则按 ID 查找需要扫描整个集合。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-189">Unless you also know the timestamp, a lookup by ID requires scanning the entire collection.</span></span> <span data-ttu-id="c6f6b-190">因此，交付历史记录服务还会将一部分历史数据存储在 Cosmos DB 中，以加快查找速度。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-190">Therefore, the Delivery History service also stores a subset of the historical data in Cosmos DB for quicker lookup.</span></span> <span data-ttu-id="c6f6b-191">记录不需要无限期保留在 Cosmos DB 中。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-191">The records don't need to stay in Cosmos DB indefinitely.</span></span> <span data-ttu-id="c6f6b-192">可将旧的交付记录存档 &mdash; 例如，超过一个月的记录。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-192">Older deliveries can be archived &mdash; say, after a month.</span></span> <span data-ttu-id="c6f6b-193">为此，可以偶尔运行批处理。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-193">This could be done by running an occasional batch process.</span></span>

### <a name="package-service"></a><span data-ttu-id="c6f6b-194">包裹服务</span><span class="sxs-lookup"><span data-stu-id="c6f6b-194">Package service</span></span>

<span data-ttu-id="c6f6b-195">包裹服务存储有关所有包裹的信息。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-195">The Package service stores information about all of the packages.</span></span> <span data-ttu-id="c6f6b-196">包裹的存储要求如下：</span><span class="sxs-lookup"><span data-stu-id="c6f6b-196">The storage requirements for the Package are:</span></span> 

- <span data-ttu-id="c6f6b-197">长期存储。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-197">Long-term storage.</span></span>
- <span data-ttu-id="c6f6b-198">能够处理大量包裹，需要较高的写入吞吐量。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-198">Able to handle a high volume of packages, requiring high write throughput.</span></span>
- <span data-ttu-id="c6f6b-199">支持按包裹 ID 执行简单查询。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-199">Support simple queries by package ID.</span></span> <span data-ttu-id="c6f6b-200">无需复杂的联接，不存在引用完整性方面的要求。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-200">No complex joins or requirements for referential integrity.</span></span>

<span data-ttu-id="c6f6b-201">由于包裹数据不是关系型的，因此面向文档的数据库比较合适，另外，Cosmos DB 可以使用分片集合实现极高的吞吐量。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-201">Because the package data is not relational, a document oriented database is appropriate, and Cosmos DB can achieve very high throughput by using sharded collections.</span></span> <span data-ttu-id="c6f6b-202">使用包裹服务的团队比较熟悉 MEAN 堆栈（MongoDB、Express.js、AngularJS 和 Node.js），因此他们选择了适用于 Cosmos DB 的 [MongoDB API](/azure/cosmos-db/mongodb-introduction)。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-202">The team that works on the Package service is familiar with the MEAN stack (MongoDB, Express.js, AngularJS, and Node.js), so they select the [MongoDB API](/azure/cosmos-db/mongodb-introduction) for Cosmos DB.</span></span> <span data-ttu-id="c6f6b-203">这样，他们便可以利用现有的 MongoDB 经验，同时获得 Cosmos DB（Azure 托管服务）的优势。</span><span class="sxs-lookup"><span data-stu-id="c6f6b-203">That lets them leverage their existing experience with MongoDB, while getting the benefits of Cosmos DB, which is a managed Azure service.</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="c6f6b-204">服务间通信</span><span class="sxs-lookup"><span data-stu-id="c6f6b-204">Interservice communication</span></span>](./interservice-communication.md)