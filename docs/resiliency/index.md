---
title: 设计适用于 Azure 的可复原应用程序
description: 如何在 Azure 中生成可复原应用程序，以实现高可用性和灾难恢复。
author: MikeWasson
ms.date: 05/26/2017
ms.custom: resiliency
pnp.series.title: Design for Resiliency
ms.openlocfilehash: 9a6bd1332ea59923b32379018060403024b15e10
ms.sourcegitcommit: f665226cec96ec818ca06ac6c2d83edb23c9f29c
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/16/2018
---
# <a name="designing-resilient-applications-for-azure"></a><span data-ttu-id="89427-103">设计适用于 Azure 的可复原应用程序</span><span class="sxs-lookup"><span data-stu-id="89427-103">Designing resilient applications for Azure</span></span>

<span data-ttu-id="89427-104">在分布式系统中，故障时有发生。</span><span class="sxs-lookup"><span data-stu-id="89427-104">In a distributed system, failures will happen.</span></span> <span data-ttu-id="89427-105">硬件可能发生故障。</span><span class="sxs-lookup"><span data-stu-id="89427-105">Hardware can fail.</span></span> <span data-ttu-id="89427-106">网络也有可能发生暂时性故障。</span><span class="sxs-lookup"><span data-stu-id="89427-106">The network can have transient failures.</span></span> <span data-ttu-id="89427-107">极少数情况下，整个服务或区域可能会遇到中断，但这些故障必须在计划之内。</span><span class="sxs-lookup"><span data-stu-id="89427-107">Rarely, an entire service or region may experience a disruption, but even those must be planned for.</span></span> 

<span data-ttu-id="89427-108">在云中生成可靠应用程序不同于在企业设置中生成可靠应用程序。</span><span class="sxs-lookup"><span data-stu-id="89427-108">Building a reliable application in the cloud is different than building a reliable application in an enterprise setting.</span></span> <span data-ttu-id="89427-109">尽管在传统上我们可以采购可纵向扩展的高端硬件，但在云环境中，我们必须使用可横向扩展而不是纵向扩展的硬件。</span><span class="sxs-lookup"><span data-stu-id="89427-109">While historically you may have purchased higher-end hardware to scale up, in a cloud environment you must scale out instead of scaling up.</span></span> <span data-ttu-id="89427-110">可以使用市售硬件来保持云环境的较低成本。</span><span class="sxs-lookup"><span data-stu-id="89427-110">Costs for cloud environments are kept low through the use of commodity hardware.</span></span> <span data-ttu-id="89427-111">在此新环境中，我们的注意力不应该是防范故障和优化“平均故障时间”，而应该将注意力转移到“平均还原时间”。</span><span class="sxs-lookup"><span data-stu-id="89427-111">Instead of focusing on preventing failures and optimizing "mean time between failures," in this new environment the focus shifts to "mean time to restore."</span></span> <span data-ttu-id="89427-112">目标是最大程度地降低故障造成的影响。</span><span class="sxs-lookup"><span data-stu-id="89427-112">The goal is to minimize the effect of a failure.</span></span>

<span data-ttu-id="89427-113">本文概述如何在 Microsoft Azure 中生成可复原的应用程序。</span><span class="sxs-lookup"><span data-stu-id="89427-113">This article provides an overview of how to build resilient applications in Microsoft Azure.</span></span> <span data-ttu-id="89427-114">首先解释术语“复原”的定义和相关概念。</span><span class="sxs-lookup"><span data-stu-id="89427-114">It starts with a definition of the term *resiliency* and related concepts.</span></span> <span data-ttu-id="89427-115">然后，介绍在应用程序从设计和实施到部署和运营的整个生存期内，使用结构化的方法实现复原的过程。</span><span class="sxs-lookup"><span data-stu-id="89427-115">Then it describes a process for achieving resiliency, using a structured approach over the lifetime of an application, from design and implementation to deployment and operations.</span></span>

## <a name="what-is-resiliency"></a><span data-ttu-id="89427-116">什么是复原？</span><span class="sxs-lookup"><span data-stu-id="89427-116">What is resiliency?</span></span>
<span data-ttu-id="89427-117">**复原**是指系统能够在发生故障后进行恢复，然后继续正常运行。</span><span class="sxs-lookup"><span data-stu-id="89427-117">**Resiliency** is the ability of a system to recover from failures and continue to function.</span></span> <span data-ttu-id="89427-118">复原并不旨在避免故障发生，而是通过响应故障来避免故障时间或数据丢失。</span><span class="sxs-lookup"><span data-stu-id="89427-118">It's not about *avoiding* failures, but *responding* to failures in a way that avoids downtime or data loss.</span></span> <span data-ttu-id="89427-119">复原的目标是在故障发生后将应用程序恢复到可完全正常运行的状态。</span><span class="sxs-lookup"><span data-stu-id="89427-119">The goal of resiliency is to return the application to a fully functioning state following a failure.</span></span>

<span data-ttu-id="89427-120">复原的两个重要方面是高可用性和灾难恢复。</span><span class="sxs-lookup"><span data-stu-id="89427-120">Two important aspects of resiliency are high availability and disaster recovery.</span></span>

* <span data-ttu-id="89427-121">**高可用性** (HA) 是指应用程序能够在正常状态下继续运行，而没有显著增加的故障时间。</span><span class="sxs-lookup"><span data-stu-id="89427-121">**High availability** (HA) is the ability of the application to continue running in a healthy state, without significant downtime.</span></span> <span data-ttu-id="89427-122">所谓的“正常状态”是指，应用程序有响应，用户可以连接到应用程序，并与之交互。</span><span class="sxs-lookup"><span data-stu-id="89427-122">By "healthy state," we mean the application is responsive, and users can connect to the application and interact with it.</span></span>  
* <span data-ttu-id="89427-123">**灾难恢复** (DR) 是指能够从罕见但非常重大的事件（非暂时性的大规模故障，如影响整个区域的服务中断）中恢复。</span><span class="sxs-lookup"><span data-stu-id="89427-123">**Disaster recovery** (DR) is the ability to recover from rare but major incidents: non-transient, wide-scale failures, such as service disruption that affects an entire region.</span></span> <span data-ttu-id="89427-124">灾难恢复包括数据备份和存档，并且可能包括手动干预，如通过备份还原数据库。</span><span class="sxs-lookup"><span data-stu-id="89427-124">Disaster recovery includes data backup and archiving, and may include manual intervention, such as restoring a database from backup.</span></span>

<span data-ttu-id="89427-125">选择 HA 还是 DR 的一种思路是，如果故障造成的影响超过了 HA 的应对能力，则应该首选 DR。</span><span class="sxs-lookup"><span data-stu-id="89427-125">One way to think about HA versus DR is that DR starts when the impact of a fault exceeds the ability of the HA design to handle it.</span></span>  

<span data-ttu-id="89427-126">设计复原能力时，必须了解可用性要求。</span><span class="sxs-lookup"><span data-stu-id="89427-126">When you design resiliency, you must understand your availability requirements.</span></span> <span data-ttu-id="89427-127">可以接受多长的故障时间？</span><span class="sxs-lookup"><span data-stu-id="89427-127">How much downtime is acceptable?</span></span> <span data-ttu-id="89427-128">这在一定程度上取决于成本。</span><span class="sxs-lookup"><span data-stu-id="89427-128">This is partly a function of cost.</span></span> <span data-ttu-id="89427-129">潜在的停机会给业务造成多大的损失？</span><span class="sxs-lookup"><span data-stu-id="89427-129">How much will potential downtime cost your business?</span></span> <span data-ttu-id="89427-130">使应用程序保持高可用性需要投入多少资金？</span><span class="sxs-lookup"><span data-stu-id="89427-130">How much should you invest in making the application highly available?</span></span> <span data-ttu-id="89427-131">此外，必须定义应用程序的可用性具体指的是什么。</span><span class="sxs-lookup"><span data-stu-id="89427-131">You also have to define what it means for the application to be available.</span></span> <span data-ttu-id="89427-132">例如，应用程序“故障”是否指的是客户可以提交订单，但系统无法在正常时限内处理该订单？</span><span class="sxs-lookup"><span data-stu-id="89427-132">For example, is the application "down" if a customer can submit an order but the system cannot process it within the normal timeframe?</span></span> <span data-ttu-id="89427-133">此外，还要考虑发生特定类型的服务中断的概率，以及缓解策略是否经济高效。</span><span class="sxs-lookup"><span data-stu-id="89427-133">Also consider the probability of a particular type of outage occurring, and whether a mitigation strategy is cost-effective.</span></span>

<span data-ttu-id="89427-134">另一个常见术语是**业务连续性** (BC)，指的是在发生不利条件（例如自然灾难或服务中断）期间和之后，执行关键业务功能的能力。</span><span class="sxs-lookup"><span data-stu-id="89427-134">Another common term is **business continuity** (BC), which is the ability to perform essential business functions during and after adverse conditions, such as a natural disaster or a downed service.</span></span> <span data-ttu-id="89427-135">BC 涵盖整个业务运营，包括物理设施、人员、通信、运输和 IT。</span><span class="sxs-lookup"><span data-stu-id="89427-135">BC covers the entire operation of the business, including physical facilities, people, communications, transportation, and IT.</span></span> <span data-ttu-id="89427-136">本文的重点是云应用程序，但必须在总体业务连续性要求的上下文中进行复原规划。</span><span class="sxs-lookup"><span data-stu-id="89427-136">This article focuses on cloud applications, but resilience planning must be done in the context of overall BC requirements.</span></span> 

<span data-ttu-id="89427-137">**数据备份**是灾难恢复的关键组成部分。</span><span class="sxs-lookup"><span data-stu-id="89427-137">**Data backup** is a critical part of DR.</span></span> <span data-ttu-id="89427-138">如果应用程序的无状态组件发生故障，始终可以重新部署它们。</span><span class="sxs-lookup"><span data-stu-id="89427-138">If the stateless components of an application fail, you can always redeploy them.</span></span> <span data-ttu-id="89427-139">但是，如果数据丢失，则系统无法恢复稳定状态。</span><span class="sxs-lookup"><span data-stu-id="89427-139">But if data is lost, the system can't return to a stable state.</span></span> <span data-ttu-id="89427-140">最好在不同的区域将数据备份，以防发生区域范围的灾难。</span><span class="sxs-lookup"><span data-stu-id="89427-140">Data must be backed up, ideally in a different region in case of a region-wide disaster.</span></span> 

<span data-ttu-id="89427-141">备份不同于**数据复制**。</span><span class="sxs-lookup"><span data-stu-id="89427-141">Backup is distinct from **data replication**.</span></span> <span data-ttu-id="89427-142">数据复制涉及近乎实时地复制数据，以便系统可以快速故障转移到副本。</span><span class="sxs-lookup"><span data-stu-id="89427-142">Data replication involves copying data in near-real-time, so that the system can fail over quickly to a replica.</span></span> <span data-ttu-id="89427-143">很多数据库系统支持复制；例如，SQL Server 支持 SQL Server Always On 可用性组。</span><span class="sxs-lookup"><span data-stu-id="89427-143">Many databases systems support replication; for example, SQL Server supports SQL Server Always On Availability Groups.</span></span> <span data-ttu-id="89427-144">数据复制可以减少故障后进行恢复所要花费的时间，它确保始终有一个待机的数据副本。</span><span class="sxs-lookup"><span data-stu-id="89427-144">Data replication can reduce how long it takes to recover from an outage, by ensuring that a replica of the data is always standing by.</span></span> <span data-ttu-id="89427-145">但是，数据复制无法防范人为错误。</span><span class="sxs-lookup"><span data-stu-id="89427-145">However, data replication won't protect against human error.</span></span> <span data-ttu-id="89427-146">如果数据由于人为错误而破坏，则损坏的数据只复制到副本。</span><span class="sxs-lookup"><span data-stu-id="89427-146">If data gets corrupted because of human error, the corrupted data just gets copied to the replicas.</span></span> <span data-ttu-id="89427-147">因此，仍需在灾难恢复策略中包含长期备份。</span><span class="sxs-lookup"><span data-stu-id="89427-147">Therefore, you still need to include long-term backup in your DR strategy.</span></span> 

## <a name="process-to-achieve-resiliency"></a><span data-ttu-id="89427-148">实现复原的过程</span><span class="sxs-lookup"><span data-stu-id="89427-148">Process to achieve resiliency</span></span>
<span data-ttu-id="89427-149">复原能力不是一个外加的功能。</span><span class="sxs-lookup"><span data-stu-id="89427-149">Resiliency is not an add-on.</span></span> <span data-ttu-id="89427-150">必须将其融入设计，并在运营中付诸实践。</span><span class="sxs-lookup"><span data-stu-id="89427-150">It must be designed into the system and put into operational practice.</span></span> <span data-ttu-id="89427-151">下面是要遵循的常规模型：</span><span class="sxs-lookup"><span data-stu-id="89427-151">Here is a general model to follow:</span></span>

1. <span data-ttu-id="89427-152">根据业务需求**定义**可用性要求。</span><span class="sxs-lookup"><span data-stu-id="89427-152">**Define** your availability requirements, based on business needs.</span></span>
2. <span data-ttu-id="89427-153">**设计**应用程序的复原能力。</span><span class="sxs-lookup"><span data-stu-id="89427-153">**Design** the application for resiliency.</span></span> <span data-ttu-id="89427-154">从遵循经过证实的做法的体系结构着手，识别该体系结构中可能存在的故障点。</span><span class="sxs-lookup"><span data-stu-id="89427-154">Start with an architecture that follows proven practices, and then identify the possible failure points in that architecture.</span></span>
3. <span data-ttu-id="89427-155">**实施**策略来检测故障并从中恢复。</span><span class="sxs-lookup"><span data-stu-id="89427-155">**Implement** strategies to detect and recover from failures.</span></span> 
4. <span data-ttu-id="89427-156">通过模拟故障和触发强制故障转移来**测试**实施项目。</span><span class="sxs-lookup"><span data-stu-id="89427-156">**Test** the implementation by simulating faults and triggering forced failovers.</span></span> 
5. <span data-ttu-id="89427-157">使用可靠、可重复的过程将应用程序**部署**到生产环境中。</span><span class="sxs-lookup"><span data-stu-id="89427-157">**Deploy** the application into production using a reliable, repeatable process.</span></span> 
6. <span data-ttu-id="89427-158">**监视**应用程序以检测故障。</span><span class="sxs-lookup"><span data-stu-id="89427-158">**Monitor** the application to detect failures.</span></span> <span data-ttu-id="89427-159">通过监视系统，可以衡量应用程序的运行状况，并在必要的情况下对事件做出响应。</span><span class="sxs-lookup"><span data-stu-id="89427-159">By monitoring the system, you can gauge the health of the application and respond to incidents if necessary.</span></span> 
7. <span data-ttu-id="89427-160">发生需要人工干预的事件时做出**响应**。</span><span class="sxs-lookup"><span data-stu-id="89427-160">**Respond** if there are incidents that require manual interventions.</span></span>

<span data-ttu-id="89427-161">本文的余下部分将更详细地介绍上述每个步骤。</span><span class="sxs-lookup"><span data-stu-id="89427-161">In the remainder of this article, we discuss each of these steps in more detail.</span></span>

## <a name="defining-your-resiliency-requirements"></a><span data-ttu-id="89427-162">定义复原要求</span><span class="sxs-lookup"><span data-stu-id="89427-162">Defining your resiliency requirements</span></span>
<span data-ttu-id="89427-163">复原规划从业务要求开始。</span><span class="sxs-lookup"><span data-stu-id="89427-163">Resiliency planning starts with business requirements.</span></span> <span data-ttu-id="89427-164">可参考以下几点思路来考虑这项规划。</span><span class="sxs-lookup"><span data-stu-id="89427-164">Here are some approaches for thinking about resiliency in those terms.</span></span>

### <a name="decompose-by-workload"></a><span data-ttu-id="89427-165">按工作负荷分解</span><span class="sxs-lookup"><span data-stu-id="89427-165">Decompose by workload</span></span>
<span data-ttu-id="89427-166">许多云解决方案包括多个应用程序工作负荷。</span><span class="sxs-lookup"><span data-stu-id="89427-166">Many cloud solutions consist of multiple application workloads.</span></span> <span data-ttu-id="89427-167">在此语境中，术语“工作负荷”是指某个离散的功能或计算任务，该任务根据业务逻辑和数据存储要求可与其他任务逻辑分离。</span><span class="sxs-lookup"><span data-stu-id="89427-167">The term "workload" in this context means a discrete capability or computing task, which can be logically separated from other tasks, in terms of business logic and data storage requirements.</span></span> <span data-ttu-id="89427-168">例如，电子商务应用可能包含以下工作负荷：</span><span class="sxs-lookup"><span data-stu-id="89427-168">For example, an e-commerce app might include the following workloads:</span></span>

* <span data-ttu-id="89427-169">浏览和搜索产品目录。</span><span class="sxs-lookup"><span data-stu-id="89427-169">Browse and search a product catalog.</span></span>
* <span data-ttu-id="89427-170">创建和跟踪订单。</span><span class="sxs-lookup"><span data-stu-id="89427-170">Create and track orders.</span></span>
* <span data-ttu-id="89427-171">查看推荐商品。</span><span class="sxs-lookup"><span data-stu-id="89427-171">View recommendations.</span></span>

<span data-ttu-id="89427-172">这些工作负荷在可用性、可伸缩性、数据一致性和灾难恢复等方面具有不同的要求。</span><span class="sxs-lookup"><span data-stu-id="89427-172">These workloads might have different requirements for availability, scalability, data consistency, disaster recovery, and so forth.</span></span> <span data-ttu-id="89427-173">同样，业务决策中都要考虑这些要求。</span><span class="sxs-lookup"><span data-stu-id="89427-173">Again, these are business decisions.</span></span>

<span data-ttu-id="89427-174">另外需要考虑使用模式。</span><span class="sxs-lookup"><span data-stu-id="89427-174">Also consider usage patterns.</span></span> <span data-ttu-id="89427-175">系统是否必须在某些关键时段保持可用？</span><span class="sxs-lookup"><span data-stu-id="89427-175">Are there certain critical periods when the system must be available?</span></span> <span data-ttu-id="89427-176">例如，税务申报服务不能在申报截止日期之前出现故障，视频流服务在重大赛事期间必须保持正常运行，等等。</span><span class="sxs-lookup"><span data-stu-id="89427-176">For example, a tax-filing service can't go down right before the filing deadline, a video streaming service must stay up during a big sports event, and so on.</span></span> <span data-ttu-id="89427-177">在关键时段，可以在不同的区域采用冗余部署，以便在某个区域发生故障时，应用程序可以故障转移。</span><span class="sxs-lookup"><span data-stu-id="89427-177">During the critical periods, you might have redundant deployments across several regions, so the application could fail over if one region failed.</span></span> <span data-ttu-id="89427-178">但是，多区域部署的成本更高，因此，在非关键时段，可以在单个区域运行应用程序。</span><span class="sxs-lookup"><span data-stu-id="89427-178">However, a multi-region deployment is more expensive, so during less critical times, you might run the application in a single region.</span></span>

### <a name="rto-and-rpo"></a><span data-ttu-id="89427-179">RTO 和 RPO</span><span class="sxs-lookup"><span data-stu-id="89427-179">RTO and RPO</span></span>
<span data-ttu-id="89427-180">要考虑的两个重要指标是恢复时间目标和恢复点目标。</span><span class="sxs-lookup"><span data-stu-id="89427-180">Two important metrics to consider are the recovery time objective and recovery point objective.</span></span>

* <span data-ttu-id="89427-181">**恢复时间目标** (RTO) 是指发生某个事件后，可接受应用程序不可用的最长时间。</span><span class="sxs-lookup"><span data-stu-id="89427-181">**Recovery time objective** (RTO) is the maximum acceptable time that an application can be unavailable after an incident.</span></span> <span data-ttu-id="89427-182">如果 RTO 是 90 分钟，则从发生灾难开始，必须能够在 90 分钟内将应用程序还原到正常运行状态。</span><span class="sxs-lookup"><span data-stu-id="89427-182">If your RTO is 90 minutes, you must be able to restore the application to a running state within 90 minutes from the start of a disaster.</span></span> <span data-ttu-id="89427-183">如果 RTO 极低，可以持续保持运转一个后备部署，以防范区域性服务中断。</span><span class="sxs-lookup"><span data-stu-id="89427-183">If you have a very low RTO, you might keep a second deployment continually running on standby, to protect against a regional outage.</span></span>

* <span data-ttu-id="89427-184">**恢复点目标** (RPO) 是指发生灾难期间，可接受数据丢失的最大持续时间。</span><span class="sxs-lookup"><span data-stu-id="89427-184">**Recovery point objective** (RPO) is the maximum duration of data loss that is acceptable during a disaster.</span></span> <span data-ttu-id="89427-185">例如，如果在单个数据库中存储数据并且未将数据复制到其他数据库，而是执行每小时备份，则最长可能会丢失一小时的数据。</span><span class="sxs-lookup"><span data-stu-id="89427-185">For example, if you store data in a single database, with no replication to other databases, and perform hourly backups, you could lose up to an hour of data.</span></span> 

<span data-ttu-id="89427-186">RTO 和 RPO 属于业务要求。</span><span class="sxs-lookup"><span data-stu-id="89427-186">RTO and RPO are business requirements.</span></span> <span data-ttu-id="89427-187">开展风险评估有助于定义应用程序的 RTO 和 RPO。</span><span class="sxs-lookup"><span data-stu-id="89427-187">Conducting a risk assessment can help you define the application's RTO and RPO.</span></span> <span data-ttu-id="89427-188">另一个常见的指标是**平均恢复时间** (MTTR)，指的是发生故障后，还原应用程序所花费的平均时间。</span><span class="sxs-lookup"><span data-stu-id="89427-188">Another common metric is **mean time to recover** (MTTR), which is the average time that it takes to restore the application after a failure.</span></span> <span data-ttu-id="89427-189">MTTR 是反映系统状态的经验事实。</span><span class="sxs-lookup"><span data-stu-id="89427-189">MTTR is an empirical fact about a system.</span></span> <span data-ttu-id="89427-190">如果 MTTR 超过 RTO，则系统发生故障会导致不可接受的业务中断，因为无法在定义的 RTO 内将系统还原。</span><span class="sxs-lookup"><span data-stu-id="89427-190">If MTTR exceeds the RTO, then a failure in the system will cause an unacceptable business disruption, because it won't be possible to restore the system within the defined RTO.</span></span> 

### <a name="slas"></a><span data-ttu-id="89427-191">SLA</span><span class="sxs-lookup"><span data-stu-id="89427-191">SLAs</span></span>
<span data-ttu-id="89427-192">在 Azure 中，[服务级别协议][sla] (SLA) 描述 Microsoft 关于运行时间和连接方面的承诺。</span><span class="sxs-lookup"><span data-stu-id="89427-192">In Azure, the [Service Level Agreement][sla] (SLA) describes Microsoft’s commitments for uptime and connectivity.</span></span> <span data-ttu-id="89427-193">如果针对特定服务的 SLA 为 99.9%，则意味着该服务应该在 99.9% 的时间内可用。</span><span class="sxs-lookup"><span data-stu-id="89427-193">If the SLA for a particular service is 99.9%, it means you should expect the service to be available 99.9% of the time.</span></span>

> [!NOTE]
> <span data-ttu-id="89427-194">Azure SLA 还包括有关在无法满足 SLA 的情况下获取服务积点的条款，以及每个服务的“可用性”具体定义。</span><span class="sxs-lookup"><span data-stu-id="89427-194">The Azure SLA also includes provisions for obtaining a service credit if the SLA is not met, along with specific definitions of "availability" for each service.</span></span> <span data-ttu-id="89427-195">SLA 的此项规定充当强制策略。</span><span class="sxs-lookup"><span data-stu-id="89427-195">That aspect of the SLA acts as an enforcement policy.</span></span> 
> 
> 

<span data-ttu-id="89427-196">应该针对解决方案中的每个工作负荷定义自己的目标 SLA。</span><span class="sxs-lookup"><span data-stu-id="89427-196">You should define your own target SLAs for each workload in your solution.</span></span> <span data-ttu-id="89427-197">通过 SLA 可以评估体系结构是否满足业务要求。</span><span class="sxs-lookup"><span data-stu-id="89427-197">An SLA makes it possible to evaluate whether the architecture meets the business requirements.</span></span> <span data-ttu-id="89427-198">例如，如果工作负荷的运行时间需要达到 99.99%，但它依赖于 SLA 为 99.9 % 的服务，则该服务不能是系统中的单一故障点。</span><span class="sxs-lookup"><span data-stu-id="89427-198">For example, if a workload requires 99.99% uptime, but depends on a service with a 99.9% SLA, that service cannot be a single-point of failure in the system.</span></span> <span data-ttu-id="89427-199">一种补救措施是建立回退路径以防该服务发生故障，或者采取其他措施，以便在该服务发生故障时进行恢复。</span><span class="sxs-lookup"><span data-stu-id="89427-199">One remedy is to have a fallback path in case the service fails, or take other measures to recover from a failure in that service.</span></span> 

<span data-ttu-id="89427-200">下表显示了各个 SLA 级别的潜在累积停机时间。</span><span class="sxs-lookup"><span data-stu-id="89427-200">The following table shows the potential cumulative downtime for various SLA levels.</span></span> 

| <span data-ttu-id="89427-201">SLA</span><span class="sxs-lookup"><span data-stu-id="89427-201">SLA</span></span> | <span data-ttu-id="89427-202">每周故障时间</span><span class="sxs-lookup"><span data-stu-id="89427-202">Downtime per week</span></span> | <span data-ttu-id="89427-203">每月故障时间</span><span class="sxs-lookup"><span data-stu-id="89427-203">Downtime per month</span></span> | <span data-ttu-id="89427-204">每年故障时间</span><span class="sxs-lookup"><span data-stu-id="89427-204">Downtime per year</span></span> |
| --- | --- | --- | --- |
| <span data-ttu-id="89427-205">99%</span><span class="sxs-lookup"><span data-stu-id="89427-205">99%</span></span> |<span data-ttu-id="89427-206">1.68 小时</span><span class="sxs-lookup"><span data-stu-id="89427-206">1.68 hours</span></span> |<span data-ttu-id="89427-207">7.2 小时</span><span class="sxs-lookup"><span data-stu-id="89427-207">7.2 hours</span></span> |<span data-ttu-id="89427-208">3.65 天</span><span class="sxs-lookup"><span data-stu-id="89427-208">3.65 days</span></span> |
| <span data-ttu-id="89427-209">99.9%</span><span class="sxs-lookup"><span data-stu-id="89427-209">99.9%</span></span> |<span data-ttu-id="89427-210">10.1 分钟</span><span class="sxs-lookup"><span data-stu-id="89427-210">10.1 minutes</span></span> |<span data-ttu-id="89427-211">43.2 分钟</span><span class="sxs-lookup"><span data-stu-id="89427-211">43.2 minutes</span></span> |<span data-ttu-id="89427-212">8.76 小时</span><span class="sxs-lookup"><span data-stu-id="89427-212">8.76 hours</span></span> |
| <span data-ttu-id="89427-213">99.95%</span><span class="sxs-lookup"><span data-stu-id="89427-213">99.95%</span></span> |<span data-ttu-id="89427-214">5 分钟</span><span class="sxs-lookup"><span data-stu-id="89427-214">5 minutes</span></span> |<span data-ttu-id="89427-215">21.6 分钟</span><span class="sxs-lookup"><span data-stu-id="89427-215">21.6 minutes</span></span> |<span data-ttu-id="89427-216">4.38 小时</span><span class="sxs-lookup"><span data-stu-id="89427-216">4.38 hours</span></span> |
| <span data-ttu-id="89427-217">99.99%</span><span class="sxs-lookup"><span data-stu-id="89427-217">99.99%</span></span> |<span data-ttu-id="89427-218">1.01 分钟</span><span class="sxs-lookup"><span data-stu-id="89427-218">1.01 minutes</span></span> |<span data-ttu-id="89427-219">4.32 分钟</span><span class="sxs-lookup"><span data-stu-id="89427-219">4.32 minutes</span></span> |<span data-ttu-id="89427-220">52.56 分钟</span><span class="sxs-lookup"><span data-stu-id="89427-220">52.56 minutes</span></span> |
| <span data-ttu-id="89427-221">99.999%</span><span class="sxs-lookup"><span data-stu-id="89427-221">99.999%</span></span> |<span data-ttu-id="89427-222">6 秒</span><span class="sxs-lookup"><span data-stu-id="89427-222">6 seconds</span></span> |<span data-ttu-id="89427-223">25.9 秒</span><span class="sxs-lookup"><span data-stu-id="89427-223">25.9 seconds</span></span> |<span data-ttu-id="89427-224">5.26 分钟</span><span class="sxs-lookup"><span data-stu-id="89427-224">5.26 minutes</span></span> |

<span data-ttu-id="89427-225">当然，在其他条件相同的情况下，可用性越高越好。</span><span class="sxs-lookup"><span data-stu-id="89427-225">Of course, higher availability is better, everything else being equal.</span></span> <span data-ttu-id="89427-226">不过，如果追求更多的 9，则实现该可用性级别所带来的成本和复杂性也会增大。</span><span class="sxs-lookup"><span data-stu-id="89427-226">But as you strive for more 9s, the cost and complexity to achieve that level of availability grows.</span></span> <span data-ttu-id="89427-227">99.99% 运行时间相当于每月的总停机时间大约为 5 分钟。</span><span class="sxs-lookup"><span data-stu-id="89427-227">An uptime of 99.99% translates to about 5 minutes of total downtime per month.</span></span> <span data-ttu-id="89427-228">是否值得提高复杂性和成本来实现五个 9 的可用性？</span><span class="sxs-lookup"><span data-stu-id="89427-228">Is it worth the additional complexity and cost to reach five 9s?</span></span> <span data-ttu-id="89427-229">答案取决于业务要求。</span><span class="sxs-lookup"><span data-stu-id="89427-229">The answer depends on the business requirements.</span></span> 

<span data-ttu-id="89427-230">下面是定义 SLA 时需要考虑的其他一些因素：</span><span class="sxs-lookup"><span data-stu-id="89427-230">Here are some other considerations when defining an SLA:</span></span>

* <span data-ttu-id="89427-231">若要实现四个 9 (99.99%)，也许就不能依赖于人工干预来从故障中恢复。</span><span class="sxs-lookup"><span data-stu-id="89427-231">To achieve four 9's (99.99%), you probably can't rely on manual intervention to recover from failures.</span></span> <span data-ttu-id="89427-232">应用程序必须能够自我诊断和自我修复。</span><span class="sxs-lookup"><span data-stu-id="89427-232">The application must be self-diagnosing and self-healing.</span></span> 
* <span data-ttu-id="89427-233">如果超过四个 9，将很难根据 SLA 的要求以足够快的速度检测到服务中断。</span><span class="sxs-lookup"><span data-stu-id="89427-233">Beyond four 9's, it is challenging to detect outages quickly enough to meet the SLA.</span></span>
* <span data-ttu-id="89427-234">请考虑衡量 SLA 时所依据的时限。</span><span class="sxs-lookup"><span data-stu-id="89427-234">Think about the time window that your SLA is measured against.</span></span> <span data-ttu-id="89427-235">该时限越小，容限就越严格。</span><span class="sxs-lookup"><span data-stu-id="89427-235">The smaller the window, the tighter the tolerances.</span></span> <span data-ttu-id="89427-236">根据每小时或每日运行时间定义 SLA 可能没有意义。</span><span class="sxs-lookup"><span data-stu-id="89427-236">It probably doesn't make sense to define your SLA in terms of hourly or daily uptime.</span></span> 

### <a name="composite-slas"></a><span data-ttu-id="89427-237">复合 SLA</span><span class="sxs-lookup"><span data-stu-id="89427-237">Composite SLAs</span></span>
<span data-ttu-id="89427-238">请考虑一个要在 Azure SQL 数据库中写入数据的应用服务 Web 应用。</span><span class="sxs-lookup"><span data-stu-id="89427-238">Consider an App Service web app that writes to Azure SQL Database.</span></span> <span data-ttu-id="89427-239">在撰写本文时，这些 Azure 服务的 SLA 如下：</span><span class="sxs-lookup"><span data-stu-id="89427-239">At the time of this writing, these Azure services have the following SLAs:</span></span>

* <span data-ttu-id="89427-240">应用服务 Web 应用 = 99.95%</span><span class="sxs-lookup"><span data-stu-id="89427-240">App Service Web Apps = 99.95%</span></span>
* <span data-ttu-id="89427-241">SQL 数据库 = 99.99%</span><span class="sxs-lookup"><span data-stu-id="89427-241">SQL Database = 99.99%</span></span>

![复合 SLA](./images/sla1.png)

<span data-ttu-id="89427-243">此应用程序的预期最大停机时间是多少？</span><span class="sxs-lookup"><span data-stu-id="89427-243">What is the maximum downtime you would expect for this application?</span></span> <span data-ttu-id="89427-244">如果任一服务发生故障，整个应用程序也会发生故障。</span><span class="sxs-lookup"><span data-stu-id="89427-244">If either service fails, the whole application fails.</span></span> <span data-ttu-id="89427-245">一般情况下，每个服务发生故障的概率是自主性的，因此，此应用程序的复合 SLA 为 99.95% &times; 99.99%= 99.94%。</span><span class="sxs-lookup"><span data-stu-id="89427-245">In general, the probability of each service failing is independent, so the composite SLA for this application is 99.95% &times; 99.99% = 99.94%.</span></span> <span data-ttu-id="89427-246">这比单个 SLA 更低，但不让人意外，因为依赖于多个服务的应用程序具有更多的潜在故障点。</span><span class="sxs-lookup"><span data-stu-id="89427-246">That's lower than the individual SLAs, which isn't surprising, because an application that relies on multiple services has more potential failure points.</span></span> 

<span data-ttu-id="89427-247">另一方面，可以通过创建独立的回退路径来提高复合 SLA。</span><span class="sxs-lookup"><span data-stu-id="89427-247">On the other hand, you can improve the composite SLA by creating independent fallback paths.</span></span> <span data-ttu-id="89427-248">例如，如果 SQL 数据库不可用，可将事务放入队列供稍后处理。</span><span class="sxs-lookup"><span data-stu-id="89427-248">For example, if SQL Database is unavailable, put transactions into a queue, to be processed later.</span></span>

![复合 SLA](./images/sla2.png)

<span data-ttu-id="89427-250">如果采用这种设计，即使应用程序无法连接到数据库，它也能保持可用性。</span><span class="sxs-lookup"><span data-stu-id="89427-250">With this design, the application is still available even if it can't connect to the database.</span></span> <span data-ttu-id="89427-251">但是，如果数据库和队列同时发生故障，则应用程序也会发生故障。</span><span class="sxs-lookup"><span data-stu-id="89427-251">However, it fails if the database and the queue both fail at the same time.</span></span> <span data-ttu-id="89427-252">同时发生故障的预期时间百分比是 0.0001 &times; 0.001，因此，此组合路径的复合 SLA 是：</span><span class="sxs-lookup"><span data-stu-id="89427-252">The expected percentage of time for a simultaneous failure is 0.0001 &times; 0.001, so the composite SLA for this combined path is:</span></span>  

* <span data-ttu-id="89427-253">数据库或队列 = 1.0 &minus; (0.0001 &times; 0.001) = 99.99999%</span><span class="sxs-lookup"><span data-stu-id="89427-253">Database OR queue = 1.0 &minus; (0.0001 &times; 0.001) = 99.99999%</span></span>

<span data-ttu-id="89427-254">总复合 SLA 是：</span><span class="sxs-lookup"><span data-stu-id="89427-254">The total composite SLA is:</span></span>

* <span data-ttu-id="89427-255">Web 应用和（数据库或队列）= 99.95% &times; 99.99999%= ~99.95%</span><span class="sxs-lookup"><span data-stu-id="89427-255">Web app AND (database OR queue) = 99.95% &times; 99.99999% = ~99.95%</span></span>

<span data-ttu-id="89427-256">但是，这种方法存在几个缺点。</span><span class="sxs-lookup"><span data-stu-id="89427-256">But there are tradeoffs to this approach.</span></span> <span data-ttu-id="89427-257">应用程序逻辑更复杂，因此需要支付队列费用，另外，可能还要考虑到数据一致性问题。</span><span class="sxs-lookup"><span data-stu-id="89427-257">The application logic is more complex, you are paying for the queue, and there may be data consistency issues to consider.</span></span>

<span data-ttu-id="89427-258">**多区域部署的 SLA**。</span><span class="sxs-lookup"><span data-stu-id="89427-258">**SLA for multi-region deployments**.</span></span> <span data-ttu-id="89427-259">另一种 HA 技术是在多个区域中部署应用程序，当一个区域中的应用程序发生故障时，可以使用 Azure 流量管理器实现故障转移。</span><span class="sxs-lookup"><span data-stu-id="89427-259">Another HA technique is to deploy the application in more than one region, and use Azure Traffic Manager to fail over if the application fails in one region.</span></span> <span data-ttu-id="89427-260">对于双区域部署，复合 SLA 的计算方式如下。</span><span class="sxs-lookup"><span data-stu-id="89427-260">For a two-region deployment, the composite SLA is calculated as follows.</span></span> 

<span data-ttu-id="89427-261">让 *N* 成为一个区域中部署的应用程序的复合 SLA。</span><span class="sxs-lookup"><span data-stu-id="89427-261">Let *N* be the composite SLA for the application deployed in one region.</span></span> <span data-ttu-id="89427-262">应用程序在两个区域中同时发生故障的预期可能性为 (1 &minus; N) &times; (1 &minus; N)。</span><span class="sxs-lookup"><span data-stu-id="89427-262">The expected chance that the application will fail in both regions at the same time is (1 &minus; N) &times; (1 &minus; N).</span></span> <span data-ttu-id="89427-263">因此，</span><span class="sxs-lookup"><span data-stu-id="89427-263">Therefore,</span></span>

* <span data-ttu-id="89427-264">两个区域的组合 SLA = 1 &minus; (1 &minus; N)(1 &minus; N) = N + (1 &minus; N)N</span><span class="sxs-lookup"><span data-stu-id="89427-264">Combined SLA for both regions = 1 &minus; (1 &minus; N)(1 &minus; N) = N + (1 &minus; N)N</span></span>

<span data-ttu-id="89427-265">最后，必须考虑[流量管理器的 SLA][tm-sla]。</span><span class="sxs-lookup"><span data-stu-id="89427-265">Finally, you must factor in the [SLA for Traffic Manager][tm-sla].</span></span> <span data-ttu-id="89427-266">在撰写本文时，流量管理器的 SLA 为 99.99%。</span><span class="sxs-lookup"><span data-stu-id="89427-266">At the time of this writing, the SLA for Traffic Manager SLA is 99.99%.</span></span>

* <span data-ttu-id="89427-267">复合 SLA = 99.99% &times; (两个区域的合并 SLA)</span><span class="sxs-lookup"><span data-stu-id="89427-267">Composite SLA = 99.99% &times; (combined SLA for both regions)</span></span>

<span data-ttu-id="89427-268">此外，故障转移不能瞬间完成，在故障转移期间，可能会造成一段停机时间。</span><span class="sxs-lookup"><span data-stu-id="89427-268">Also, failing over is not instantaneous and can result in some downtime during a failover.</span></span> <span data-ttu-id="89427-269">请参阅[流量管理器终结点监视和故障转移][tm-failover]。</span><span class="sxs-lookup"><span data-stu-id="89427-269">See [Traffic Manager endpoint monitoring and failover][tm-failover].</span></span>

<span data-ttu-id="89427-270">计算出的 SLA 数字是个有用的基线，但不能反映可用性的方方面面。</span><span class="sxs-lookup"><span data-stu-id="89427-270">The calculated SLA number is a useful baseline, but it doesn't tell the whole story about availability.</span></span> <span data-ttu-id="89427-271">通常，在非关键路径发生故障时，应用程序的可用性可以正常降级。</span><span class="sxs-lookup"><span data-stu-id="89427-271">Often, an application can degrade gracefully when a non-critical path fails.</span></span> <span data-ttu-id="89427-272">假设某个应用程序显示图书目录。</span><span class="sxs-lookup"><span data-stu-id="89427-272">Consider an application that shows a catalog of books.</span></span> <span data-ttu-id="89427-273">如果该应用程序无法检索封面的缩略图图像，它可能显示占位符图像。</span><span class="sxs-lookup"><span data-stu-id="89427-273">If the application can't retrieve the thumbnail image for the cover, it might show a placeholder image.</span></span> <span data-ttu-id="89427-274">在这种情况下，无法获取该图像并不会减少应用程序的运行时间，不过会影响用户体验。</span><span class="sxs-lookup"><span data-stu-id="89427-274">In that case, failing to get the image does not reduce the application's uptime, although it affects the user experience.</span></span>  

## <a name="redundancy-and-designing-for-failure"></a><span data-ttu-id="89427-275">冗余和故障设计</span><span class="sxs-lookup"><span data-stu-id="89427-275">Redundancy and designing for failure</span></span>

<span data-ttu-id="89427-276">故障的影响范围各不相同。</span><span class="sxs-lookup"><span data-stu-id="89427-276">Failures can vary in the scope of their impact.</span></span> <span data-ttu-id="89427-277">某些硬件故障（例如磁盘故障）可能影响单个主机。</span><span class="sxs-lookup"><span data-stu-id="89427-277">Some hardware failures, such as a failed disk, may affect a single host machine.</span></span> <span data-ttu-id="89427-278">网络交换机故障可能影响整个服务器机架。</span><span class="sxs-lookup"><span data-stu-id="89427-278">A failed network switch could affect a whole server rack.</span></span> <span data-ttu-id="89427-279">中断整个数据中心的故障（例如数据中心断电）不太常见。</span><span class="sxs-lookup"><span data-stu-id="89427-279">Less common are failures that disrupt a whole data center, such as loss of power in a data center.</span></span> <span data-ttu-id="89427-280">在极少数情况下，整个区域可能不可用。</span><span class="sxs-lookup"><span data-stu-id="89427-280">Rarely, an entire region could become unavailable.</span></span>

<span data-ttu-id="89427-281">冗余是让应用程序保持弹性的方法之一。</span><span class="sxs-lookup"><span data-stu-id="89427-281">One of the main ways to make an application resilient is through redundancy.</span></span> <span data-ttu-id="89427-282">但是，需要在计划应用程序时规划这种冗余。</span><span class="sxs-lookup"><span data-stu-id="89427-282">But you need to plan for this redundancy when you design the application.</span></span> <span data-ttu-id="89427-283">此外，所需的冗余级别取决于业务要求 &mdash; 并非每个应用程序都需要跨区域的冗余才能防范区域性服务中断。</span><span class="sxs-lookup"><span data-stu-id="89427-283">Also, the level of redundancy that you need depends on your business requirements &mdash; not every application needs redundancy across regions to guard against a regional outage.</span></span> <span data-ttu-id="89427-284">一般情况下，提高冗余和可靠性的弊端就是增大成本和复杂性。</span><span class="sxs-lookup"><span data-stu-id="89427-284">In general, there is a tradeoff between greater redundancy and reliability versus higher cost and complexity.</span></span>  

<span data-ttu-id="89427-285">Azure 提供许多功能用于实现每个故障级别的应用程序冗余，从单个 VM 到整个区域。</span><span class="sxs-lookup"><span data-stu-id="89427-285">Azure has a number of features to make an application redundant at every level of failure, from an individual VM to an entire region.</span></span> 

![](./images/redundancy.svg)

<span data-ttu-id="89427-286">**单个 VM**。</span><span class="sxs-lookup"><span data-stu-id="89427-286">**Single VM**.</span></span> <span data-ttu-id="89427-287">Azure 针对单个 VM 提供运行时间 SLA。</span><span class="sxs-lookup"><span data-stu-id="89427-287">Azure provides an uptime SLA for single VMs.</span></span> <span data-ttu-id="89427-288">尽管可以通过运行两个或更多个 VM 来获得更高的 SLA，则对于某些工作负荷而言，单个 VM 可能已足够可靠。</span><span class="sxs-lookup"><span data-stu-id="89427-288">Although you can get a higher SLA by running two or more VMs, a single VM may be reliable enough for some workloads.</span></span> <span data-ttu-id="89427-289">对于生产工作负荷，我们建议使用两个或更多个 VM 来实现冗余。</span><span class="sxs-lookup"><span data-stu-id="89427-289">For production workloads, we recommend using two or more VMs for redundancy.</span></span> 

<span data-ttu-id="89427-290">**可用性集**。</span><span class="sxs-lookup"><span data-stu-id="89427-290">**Availability sets**.</span></span> <span data-ttu-id="89427-291">若要防范局部性硬件故障（例如磁盘或网络交换机故障），请在可用性集中部署两个或更多个 VM。</span><span class="sxs-lookup"><span data-stu-id="89427-291">To protect against localized hardware failures, such as a disk or network switch failing, deploy two or more VMs in an availability set.</span></span> <span data-ttu-id="89427-292">可用性集包括两个或更多个容错域，它们共用一个电源和网络交换机。</span><span class="sxs-lookup"><span data-stu-id="89427-292">An availability set consists of two or more *fault domains* that share a common power source and network switch.</span></span> <span data-ttu-id="89427-293">可用性集中的 VM 分布在不同的容错域中，因此，如果硬件故障影响了一个容错域，仍可将网络流量路由到其他容错域中的 VM。</span><span class="sxs-lookup"><span data-stu-id="89427-293">VMs in an availability set are distributed across the fault domains, so if a hardware failure affects one fault domain, network traffic can still be routed the VMs in the other fault domains.</span></span> <span data-ttu-id="89427-294">有关可用性集的详细信息，请参阅[在 Azure 中管理 Windows 虚拟机的可用性](/azure/virtual-machines/windows/manage-availability)。</span><span class="sxs-lookup"><span data-stu-id="89427-294">For more information about Availability Sets, see [Manage the availability of Windows virtual machines in Azure](/azure/virtual-machines/windows/manage-availability).</span></span>

<span data-ttu-id="89427-295">**可用性区域**。</span><span class="sxs-lookup"><span data-stu-id="89427-295">**Availability zones**.</span></span>  <span data-ttu-id="89427-296">可用性区域是 Azure 区域中的物理独立区域。</span><span class="sxs-lookup"><span data-stu-id="89427-296">An Availability Zone is a physically separate zone within an Azure region.</span></span> <span data-ttu-id="89427-297">每个可用性区域有独立的电源、网络和散热设备。</span><span class="sxs-lookup"><span data-stu-id="89427-297">Each Availability Zone has a distinct power source, network, and cooling.</span></span> <span data-ttu-id="89427-298">跨可用性区域部署 VM 有助于在发生数据中心范围的故障时保护应用程序。</span><span class="sxs-lookup"><span data-stu-id="89427-298">Deploying VMs across availability zones helps to protect an application against datacenter-wide failures.</span></span> 

<span data-ttu-id="89427-299">**配对区域**。</span><span class="sxs-lookup"><span data-stu-id="89427-299">**Paired regions**.</span></span> <span data-ttu-id="89427-300">若要在发生区域性服务中断时保护应用程序，可以跨多个区域部署应用程序，并使用 Azure 流量管理器将 Internet 流量分发到不同的区域。</span><span class="sxs-lookup"><span data-stu-id="89427-300">To protect an application against a regional outage, you can deploy the application across multiple regions, using Azure Traffic Manager to distribute internet traffic to the different regions.</span></span> <span data-ttu-id="89427-301">每个 Azure 区域与另一个区域配对。</span><span class="sxs-lookup"><span data-stu-id="89427-301">Each Azure region is paired with another region.</span></span> <span data-ttu-id="89427-302">它们共同构成了[区域对](/azure/best-practices-availability-paired-regions)。</span><span class="sxs-lookup"><span data-stu-id="89427-302">Together, these form a [regional pair](/azure/best-practices-availability-paired-regions).</span></span> <span data-ttu-id="89427-303">除巴西南部以外，区域对位于同一区域，以符合税务和执法管辖范围方面的数据驻留要求。</span><span class="sxs-lookup"><span data-stu-id="89427-303">With the exception of Brazil South, regional pairs are located within the same geography in order to meet data residency requirements for tax and law enforcement jurisdiction purposes.</span></span>

<span data-ttu-id="89427-304">设计多区域应用程序时，请注意跨区域的网络延迟高于区域内部的网络延迟。</span><span class="sxs-lookup"><span data-stu-id="89427-304">When you design a multi-region application, take into account that network latency across regions is higher than within a region.</span></span> <span data-ttu-id="89427-305">例如，若要复制数据库以启用故障转移，可在一个区域中使用同步数据复制，但跨区域复制时应使用异步数据复制。</span><span class="sxs-lookup"><span data-stu-id="89427-305">For example, if you are replicating a database to enable failover, use synchronous data replication within a region, but asynchronous data replication across regions.</span></span>

| &nbsp; | <span data-ttu-id="89427-306">可用性集</span><span class="sxs-lookup"><span data-stu-id="89427-306">Availability Set</span></span> | <span data-ttu-id="89427-307">可用性区域</span><span class="sxs-lookup"><span data-stu-id="89427-307">Availability Zone</span></span> | <span data-ttu-id="89427-308">配对区域</span><span class="sxs-lookup"><span data-stu-id="89427-308">Paired region</span></span> |
|--------|------------------|-------------------|---------------|
| <span data-ttu-id="89427-309">故障范围</span><span class="sxs-lookup"><span data-stu-id="89427-309">Scope of failure</span></span> | <span data-ttu-id="89427-310">机架</span><span class="sxs-lookup"><span data-stu-id="89427-310">Rack</span></span> | <span data-ttu-id="89427-311">数据中心</span><span class="sxs-lookup"><span data-stu-id="89427-311">Datacenter</span></span> | <span data-ttu-id="89427-312">区域</span><span class="sxs-lookup"><span data-stu-id="89427-312">Region</span></span> |
| <span data-ttu-id="89427-313">请求路由</span><span class="sxs-lookup"><span data-stu-id="89427-313">Request routing</span></span> | <span data-ttu-id="89427-314">负载均衡器</span><span class="sxs-lookup"><span data-stu-id="89427-314">Load Balancer</span></span> | <span data-ttu-id="89427-315">跨区域负载均衡器</span><span class="sxs-lookup"><span data-stu-id="89427-315">Cross-zone Load Balancer</span></span> | <span data-ttu-id="89427-316">流量管理器</span><span class="sxs-lookup"><span data-stu-id="89427-316">Traffic Manager</span></span> |
| <span data-ttu-id="89427-317">网络延迟</span><span class="sxs-lookup"><span data-stu-id="89427-317">Network latency</span></span> | <span data-ttu-id="89427-318">极低</span><span class="sxs-lookup"><span data-stu-id="89427-318">Very low</span></span> | <span data-ttu-id="89427-319">低</span><span class="sxs-lookup"><span data-stu-id="89427-319">Low</span></span> | <span data-ttu-id="89427-320">中到高</span><span class="sxs-lookup"><span data-stu-id="89427-320">Mid to high</span></span> |
| <span data-ttu-id="89427-321">虚拟网络</span><span class="sxs-lookup"><span data-stu-id="89427-321">Virtual network</span></span>  | <span data-ttu-id="89427-322">VNet</span><span class="sxs-lookup"><span data-stu-id="89427-322">VNet</span></span> | <span data-ttu-id="89427-323">VNet</span><span class="sxs-lookup"><span data-stu-id="89427-323">VNet</span></span> | <span data-ttu-id="89427-324">跨区域 VNet 对等互连</span><span class="sxs-lookup"><span data-stu-id="89427-324">Cross-region VNet peering</span></span> |

## <a name="designing-for-resiliency"></a><span data-ttu-id="89427-325">复原设计</span><span class="sxs-lookup"><span data-stu-id="89427-325">Designing for resiliency</span></span>
<span data-ttu-id="89427-326">在设计阶段，应执行故障模式分析 (FMA)。</span><span class="sxs-lookup"><span data-stu-id="89427-326">During the design phase, you should perform a failure mode analysis (FMA).</span></span> <span data-ttu-id="89427-327">FMA 旨在识别潜在的故障点，并定义应用程序如何对这些故障做出响应。</span><span class="sxs-lookup"><span data-stu-id="89427-327">The goal of an FMA is to identify possible points of failure, and define how the application will respond to those failures.</span></span>

* <span data-ttu-id="89427-328">应用程序如何检测此类故障？</span><span class="sxs-lookup"><span data-stu-id="89427-328">How will the application detect this type of failure?</span></span>
* <span data-ttu-id="89427-329">应用程序如何对此类故障做出响应？</span><span class="sxs-lookup"><span data-stu-id="89427-329">How will the application respond to this type of failure?</span></span>
* <span data-ttu-id="89427-330">如何记录和监视此类故障？</span><span class="sxs-lookup"><span data-stu-id="89427-330">How will you log and monitor this type of failure?</span></span> 

<span data-ttu-id="89427-331">有关 FMA 过程的详细信息以及针对 Azure 的具体建议，请参阅 [Azure 复原指南：故障模式分析][fma]。</span><span class="sxs-lookup"><span data-stu-id="89427-331">For more information about the FMA process, with specific recommendations for Azure, see [Azure resiliency guidance: Failure mode analysis][fma].</span></span>

### <a name="example-of-identifying-failure-modes-and-detection-strategy"></a><span data-ttu-id="89427-332">确定故障模式和检测策略的示例</span><span class="sxs-lookup"><span data-stu-id="89427-332">Example of identifying failure modes and detection strategy</span></span>
<span data-ttu-id="89427-333">**故障点：** 调用外部 Web 服务/API。</span><span class="sxs-lookup"><span data-stu-id="89427-333">**Failure point:** Call to an external web service / API.</span></span>

| <span data-ttu-id="89427-334">故障模式</span><span class="sxs-lookup"><span data-stu-id="89427-334">Failure mode</span></span> | <span data-ttu-id="89427-335">检测策略</span><span class="sxs-lookup"><span data-stu-id="89427-335">Detection strategy</span></span> |
| --- | --- |
| <span data-ttu-id="89427-336">服务不可用</span><span class="sxs-lookup"><span data-stu-id="89427-336">Service is unavailable</span></span> |<span data-ttu-id="89427-337">HTTP 5xx</span><span class="sxs-lookup"><span data-stu-id="89427-337">HTTP 5xx</span></span> |
| <span data-ttu-id="89427-338">限制</span><span class="sxs-lookup"><span data-stu-id="89427-338">Throttling</span></span> |<span data-ttu-id="89427-339">HTTP 429（请求过多）</span><span class="sxs-lookup"><span data-stu-id="89427-339">HTTP 429 (Too Many Requests)</span></span> |
| <span data-ttu-id="89427-340">身份验证</span><span class="sxs-lookup"><span data-stu-id="89427-340">Authentication</span></span> |<span data-ttu-id="89427-341">HTTP 401（未授权）</span><span class="sxs-lookup"><span data-stu-id="89427-341">HTTP 401 (Unauthorized)</span></span> |
| <span data-ttu-id="89427-342">响应速度慢</span><span class="sxs-lookup"><span data-stu-id="89427-342">Slow response</span></span> |<span data-ttu-id="89427-343">请求超时</span><span class="sxs-lookup"><span data-stu-id="89427-343">Request times out</span></span> |

## <a name="resiliency-strategies"></a><span data-ttu-id="89427-344">复原策略</span><span class="sxs-lookup"><span data-stu-id="89427-344">Resiliency strategies</span></span>
<span data-ttu-id="89427-345">本部分提供一些常见复原策略的调查。</span><span class="sxs-lookup"><span data-stu-id="89427-345">This section provides a survey of some common resiliency strategies.</span></span> <span data-ttu-id="89427-346">其中的大多数策略并不局限于特定的技术。</span><span class="sxs-lookup"><span data-stu-id="89427-346">Most of these are not limited to a particular technology.</span></span> <span data-ttu-id="89427-347">本部分中的说明汇总了每种技术背后的一般思路，并提供了其他阅读材料的链接。</span><span class="sxs-lookup"><span data-stu-id="89427-347">The descriptions in this section summarize the general idea behind each technique, with links to further reading.</span></span>

### <a name="retry-transient-failures"></a><span data-ttu-id="89427-348">重试暂时性故障</span><span class="sxs-lookup"><span data-stu-id="89427-348">Retry transient failures</span></span>
<span data-ttu-id="89427-349">暂时性故障可能是由于短暂的网络连接中断、删除了数据库连接或服务因繁忙而超时造成的。</span><span class="sxs-lookup"><span data-stu-id="89427-349">Transient failures can be caused by momentary loss of network connectivity, a dropped database connection, or a timeout when a service is busy.</span></span> <span data-ttu-id="89427-350">通常，只需重试请求即可解决暂时性故障。</span><span class="sxs-lookup"><span data-stu-id="89427-350">Often, a transient failure can be resolved simply by retrying the request.</span></span> <span data-ttu-id="89427-351">针对许多 Azure 服务，客户端 SDK 能够以对调用方透明的方式实施自动重试；请参阅[重试服务指南][retry-service-specific guidance]。</span><span class="sxs-lookup"><span data-stu-id="89427-351">For many Azure services, the client SDK implements automatic retries, in a way that is transparent to the caller; see [Retry service specific guidance][retry-service-specific guidance].</span></span>

<span data-ttu-id="89427-352">每次重试都会增大总延迟时间。</span><span class="sxs-lookup"><span data-stu-id="89427-352">Each retry attempt adds to the total latency.</span></span> <span data-ttu-id="89427-353">此外，如果失败的请求过多，可能会导致出现瓶颈，因为挂起的请求会在队列中累积。</span><span class="sxs-lookup"><span data-stu-id="89427-353">Also, too many failed requests can cause a bottleneck, as pending requests accumulate in the queue.</span></span> <span data-ttu-id="89427-354">这些被阻止的请求可能占用关键的系统资源，例如内存、线程、数据库连接等，从而导致连发故障。</span><span class="sxs-lookup"><span data-stu-id="89427-354">These blocked requests might hold critical system resources such as memory, threads, database connections, and so on, which can cause cascading failures.</span></span> <span data-ttu-id="89427-355">为避免此问题，可增大每两次重试的延迟时间，并限制失败请求的总数。</span><span class="sxs-lookup"><span data-stu-id="89427-355">To avoid this, increase the delay between each retry attempt, and limit the total number of failed requests.</span></span>

![复合 SLA](./images/retry.png)

<span data-ttu-id="89427-357">有关详细信息，请参阅[重试模式][retry-pattern]。</span><span class="sxs-lookup"><span data-stu-id="89427-357">For more information, see [Retry Pattern][retry-pattern].</span></span>

### <a name="load-balance-across-instances"></a><span data-ttu-id="89427-358">在实例之间负载均衡</span><span class="sxs-lookup"><span data-stu-id="89427-358">Load balance across instances</span></span>
<span data-ttu-id="89427-359">在可伸缩性方面，云应用程序应该能够通过添加更多实例来横向扩展。</span><span class="sxs-lookup"><span data-stu-id="89427-359">For scalability, a cloud application should be able to scale out by adding more instances.</span></span> <span data-ttu-id="89427-360">此方法也会改进复原能力，因为可以将不正常的实例从轮转阵容中删除。</span><span class="sxs-lookup"><span data-stu-id="89427-360">This approach also improves resiliency, because unhealthy instances can be removed from rotation.</span></span>  

<span data-ttu-id="89427-361">例如：</span><span class="sxs-lookup"><span data-stu-id="89427-361">For example:</span></span>

* <span data-ttu-id="89427-362">将两个或更多个 VM 放在负载均衡器的后面。</span><span class="sxs-lookup"><span data-stu-id="89427-362">Put two or more VMs behind a load balancer.</span></span> <span data-ttu-id="89427-363">负载均衡器可将流量分配到所有 VM。</span><span class="sxs-lookup"><span data-stu-id="89427-363">The load balancer distributes traffic to all the VMs.</span></span> <span data-ttu-id="89427-364">请参阅[运行负载均衡的 VM 以实现可伸缩性和可用性][ra-multi-vm]。</span><span class="sxs-lookup"><span data-stu-id="89427-364">See [Run load-balanced VMs for scalability and availability][ra-multi-vm].</span></span>
* <span data-ttu-id="89427-365">将 Azure 应用服务应用横向扩展到多个实例。</span><span class="sxs-lookup"><span data-stu-id="89427-365">Scale out an Azure App Service app to multiple instances.</span></span> <span data-ttu-id="89427-366">应用服务可自动在实例之间进行负载均衡。</span><span class="sxs-lookup"><span data-stu-id="89427-366">App Service automatically balances load across instances.</span></span> <span data-ttu-id="89427-367">请参阅[基本 Web 应用程序][ra-basic-web]。</span><span class="sxs-lookup"><span data-stu-id="89427-367">See [Basic web application][ra-basic-web].</span></span>
* <span data-ttu-id="89427-368">使用 [Azure 流量管理器][tm]在一组终结点之间分配流量。</span><span class="sxs-lookup"><span data-stu-id="89427-368">Use [Azure Traffic Manager][tm] to distribute traffic across a set of endpoints.</span></span>

### <a name="replicate-data"></a><span data-ttu-id="89427-369">复制数据</span><span class="sxs-lookup"><span data-stu-id="89427-369">Replicate data</span></span>
<span data-ttu-id="89427-370">复制数据是处理数据存储中非暂时性故障的常规策略。</span><span class="sxs-lookup"><span data-stu-id="89427-370">Replicating data is a general strategy for handling non-transient failures in a data store.</span></span> <span data-ttu-id="89427-371">许多存储技术（包括 Azure SQL 数据库、Cosmos DB 和 Apache Cassandra）提供内置复制。</span><span class="sxs-lookup"><span data-stu-id="89427-371">Many storage technologies provide built-in replication, including Azure SQL Database, Cosmos DB, and Apache Cassandra.</span></span>  

<span data-ttu-id="89427-372">必须同时考虑读取和写入路径。</span><span class="sxs-lookup"><span data-stu-id="89427-372">It's important to consider both the read and write paths.</span></span> <span data-ttu-id="89427-373">根据所用的存储技术，可以创建多个可写副本，或者创建单个可写副本和多个只读副本。</span><span class="sxs-lookup"><span data-stu-id="89427-373">Depending on the storage technology, you might have multiple writable replicas, or a single writable replica and multiple read-only replicas.</span></span> 

<span data-ttu-id="89427-374">为了最大程度地提高可用性，可将副本放在多个区域。</span><span class="sxs-lookup"><span data-stu-id="89427-374">To maximize availability, replicas can be placed in multiple regions.</span></span> <span data-ttu-id="89427-375">但是，这会增大复制数据时的延迟。</span><span class="sxs-lookup"><span data-stu-id="89427-375">However, this increases the latency when replicating the data.</span></span> <span data-ttu-id="89427-376">跨区域复制通常是以异步方式执行的，这意味着，如果某个副本发生故障，将无法遵循最终一致性模型，并可能会丢失数据。</span><span class="sxs-lookup"><span data-stu-id="89427-376">Typically, replicating across regions is done asynchronously, which implies an eventual consistency model and potential data loss if a replica fails.</span></span> 

### <a name="degrade-gracefully"></a><span data-ttu-id="89427-377">正常降级</span><span class="sxs-lookup"><span data-stu-id="89427-377">Degrade gracefully</span></span>
<span data-ttu-id="89427-378">如果某个服务发生故障且没有故障转移路径，应用程序有时能够正常降级，同时仍能提供可接受的用户体验。</span><span class="sxs-lookup"><span data-stu-id="89427-378">If a service fails and there is no failover path, the application may be able to degrade gracefully while still providing an acceptable user experience.</span></span> <span data-ttu-id="89427-379">例如：</span><span class="sxs-lookup"><span data-stu-id="89427-379">For example:</span></span>

* <span data-ttu-id="89427-380">将工作项放入队列供稍后处理。</span><span class="sxs-lookup"><span data-stu-id="89427-380">Put a work item on a queue, to be handled later.</span></span> 
* <span data-ttu-id="89427-381">返回一个估计值。</span><span class="sxs-lookup"><span data-stu-id="89427-381">Return an estimated value.</span></span>
* <span data-ttu-id="89427-382">使用本地缓存的数据。</span><span class="sxs-lookup"><span data-stu-id="89427-382">Use locally cached data.</span></span> 
* <span data-ttu-id="89427-383">向用户显示错误消息。</span><span class="sxs-lookup"><span data-stu-id="89427-383">Show the user an error message.</span></span> <span data-ttu-id="89427-384">（这种做法比应用程序停止响应请求更好。）</span><span class="sxs-lookup"><span data-stu-id="89427-384">(This option is better than having the application stop responding to requests.)</span></span>

### <a name="throttle-high-volume-users"></a><span data-ttu-id="89427-385">限制高访问量用户</span><span class="sxs-lookup"><span data-stu-id="89427-385">Throttle high-volume users</span></span>
<span data-ttu-id="89427-386">有时，少量的用户会造成过高的负载。</span><span class="sxs-lookup"><span data-stu-id="89427-386">Sometimes a small number of users create excessive load.</span></span> <span data-ttu-id="89427-387">这可能会对其他用户造成影响，降低应用程序的总体可用性。</span><span class="sxs-lookup"><span data-stu-id="89427-387">That can have an impact on other users, reducing the overall availability of your application.</span></span>

<span data-ttu-id="89427-388">当单个客户端发出过多的请求时，应用程序可在特定的一段时间内限制该客户端。</span><span class="sxs-lookup"><span data-stu-id="89427-388">When a single client makes an excessive number of requests, the application might throttle the client for a certain period of time.</span></span> <span data-ttu-id="89427-389">在限制期间，应用程序会拒绝来自该客户端的一部分或所有请求（取决于确切的限制策略）。</span><span class="sxs-lookup"><span data-stu-id="89427-389">During the throttling period, the application refuses some or all of the requests from that client (depending on the exact throttling strategy).</span></span> <span data-ttu-id="89427-390">限制阈值可以根据客户的服务层确定。</span><span class="sxs-lookup"><span data-stu-id="89427-390">The threshold for throttling might depend on the customer's service tier.</span></span> 

<span data-ttu-id="89427-391">限制并不意味着该客户端一定是恶意的，只表示它超出了其服务配额。</span><span class="sxs-lookup"><span data-stu-id="89427-391">Throttling does not imply the client was necessarily acting maliciously, only that it exceeded its service quota.</span></span> <span data-ttu-id="89427-392">在某些情况下，使用者可能一贯地超出其配额或行为异常。</span><span class="sxs-lookup"><span data-stu-id="89427-392">In some cases, a consumer might consistently exceed their quota or otherwise behave badly.</span></span> <span data-ttu-id="89427-393">在此情况下，可以进一步阻止该用户。</span><span class="sxs-lookup"><span data-stu-id="89427-393">In that case, you might go further and block the user.</span></span> <span data-ttu-id="89427-394">为此，通常可以阻止其 API 密钥或 IP 地址范围。</span><span class="sxs-lookup"><span data-stu-id="89427-394">Typically, this is done by blocking an API key or an IP address range.</span></span>

<span data-ttu-id="89427-395">有关详细信息，请参阅[限制模式][throttling-pattern]。</span><span class="sxs-lookup"><span data-stu-id="89427-395">For more information, see [Throttling Pattern][throttling-pattern].</span></span>

### <a name="use-a-circuit-breaker"></a><span data-ttu-id="89427-396">使用断路器</span><span class="sxs-lookup"><span data-stu-id="89427-396">Use a circuit breaker</span></span>
<span data-ttu-id="89427-397">断路器模式可以防止应用程序重复尝试执行很可能失败的操作。</span><span class="sxs-lookup"><span data-stu-id="89427-397">The Circuit Breaker pattern can prevent an application from repeatedly trying an operation that is likely to fail.</span></span> <span data-ttu-id="89427-398">这类似于物理断路器：当电路过载时，开关可断开电流。</span><span class="sxs-lookup"><span data-stu-id="89427-398">This is similar to a physical circuit breaker, a switch that interrupts the flow of current when a circuit is overloaded.</span></span>

<span data-ttu-id="89427-399">断路器中包装了对服务的调用。</span><span class="sxs-lookup"><span data-stu-id="89427-399">The circuit breaker wraps calls to a service.</span></span> <span data-ttu-id="89427-400">它具有三种状态：</span><span class="sxs-lookup"><span data-stu-id="89427-400">It has three states:</span></span>

* <span data-ttu-id="89427-401">**闭合**。</span><span class="sxs-lookup"><span data-stu-id="89427-401">**Closed**.</span></span> <span data-ttu-id="89427-402">这是正常状态。</span><span class="sxs-lookup"><span data-stu-id="89427-402">This is the normal state.</span></span> <span data-ttu-id="89427-403">断路器向服务发送请求，计数器会跟踪最近的故障数。</span><span class="sxs-lookup"><span data-stu-id="89427-403">The circuit breaker sends requests to the service, and a counter tracks the number of recent failures.</span></span> <span data-ttu-id="89427-404">如果在给定的时段内故障数超过阈值，断路器会切换到“断开”状态。</span><span class="sxs-lookup"><span data-stu-id="89427-404">If the failure count exceeds a threshold within a given time period, the circuit breaker switches to the Open state.</span></span> 
* <span data-ttu-id="89427-405">**断开**。</span><span class="sxs-lookup"><span data-stu-id="89427-405">**Open**.</span></span> <span data-ttu-id="89427-406">在此状态下，断路器会立即使所有请求失败，且不调用服务。</span><span class="sxs-lookup"><span data-stu-id="89427-406">In this state, the circuit breaker immediately fails all requests, without calling the service.</span></span> <span data-ttu-id="89427-407">应用程序应该使用缓解路径，例如，从副本中读取数据，或者只是向用户返回错误。</span><span class="sxs-lookup"><span data-stu-id="89427-407">The application should use a mitigation path, such as reading data from a replica or simply returning an error to the user.</span></span> <span data-ttu-id="89427-408">当断路器切换到“断开”状态时，会启动计时器。</span><span class="sxs-lookup"><span data-stu-id="89427-408">When the circuit breaker switches to Open, it starts a timer.</span></span> <span data-ttu-id="89427-409">计时时间已过后，断路器将切换到“半开”状态。</span><span class="sxs-lookup"><span data-stu-id="89427-409">When the timer expires, the circuit breaker switches to the Half-open state.</span></span>
* <span data-ttu-id="89427-410">**半开**。</span><span class="sxs-lookup"><span data-stu-id="89427-410">**Half-open**.</span></span> <span data-ttu-id="89427-411">在此状态下，断路器允许有限数量的请求发往服务。</span><span class="sxs-lookup"><span data-stu-id="89427-411">In this state, the circuit breaker lets a limited number of requests go through to the service.</span></span> <span data-ttu-id="89427-412">如果这些请求成功，则认为服务已恢复，断路器将切换到“闭合”状态。</span><span class="sxs-lookup"><span data-stu-id="89427-412">If they succeed, the service is assumed to be recovered, and the circuit breaker switches back to the Closed state.</span></span> <span data-ttu-id="89427-413">否则，会恢复为“断开”状态。</span><span class="sxs-lookup"><span data-stu-id="89427-413">Otherwise, it reverts to the Open state.</span></span> <span data-ttu-id="89427-414">“半开”状态可防止大量的请求涌入正在恢复中的服务。</span><span class="sxs-lookup"><span data-stu-id="89427-414">The Half-Open state prevents a recovering service from suddenly being inundated with requests.</span></span>

<span data-ttu-id="89427-415">有关详细信息，请参阅[断路器模式][circuit-breaker-pattern]。</span><span class="sxs-lookup"><span data-stu-id="89427-415">For more information, see [Circuit Breaker Pattern][circuit-breaker-pattern].</span></span>

### <a name="use-load-leveling-to-smooth-out-spikes-in-traffic"></a><span data-ttu-id="89427-416">使用负载调控来平缓流量高峰</span><span class="sxs-lookup"><span data-stu-id="89427-416">Use load leveling to smooth out spikes in traffic</span></span>
<span data-ttu-id="89427-417">应用程序可能会遇到突发流量高峰，导致后端上的服务瘫痪。</span><span class="sxs-lookup"><span data-stu-id="89427-417">Applications may experience sudden spikes in traffic, which can overwhelm services on the backend.</span></span> <span data-ttu-id="89427-418">如果后端服务无法以足够快的速度响应请求，可能会导致请求排队（备份），或导致服务限制应用程序。</span><span class="sxs-lookup"><span data-stu-id="89427-418">If a backend service cannot respond to requests quickly enough, it may cause requests to queue (back up), or cause the service to throttle the application.</span></span>

<span data-ttu-id="89427-419">为了避免此问题，可以使用队列作为缓冲区。</span><span class="sxs-lookup"><span data-stu-id="89427-419">To avoid this, you can use a queue as a buffer.</span></span> <span data-ttu-id="89427-420">出现新的工作项时，应用程序不必立即调用后端服务，而可以将工作项排队，以便以异步方式运行它。</span><span class="sxs-lookup"><span data-stu-id="89427-420">When there is a new work item, instead of calling the backend service immediately, the application queues a work item to run asynchronously.</span></span> <span data-ttu-id="89427-421">队列充当可平缓负载高峰的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="89427-421">The queue acts as a buffer that smooths out peaks in the load.</span></span> 

<span data-ttu-id="89427-422">有关详细信息，请参阅[基于队列的负载调控模式][load-leveling-pattern]。</span><span class="sxs-lookup"><span data-stu-id="89427-422">For more information, see [Queue-Based Load Leveling Pattern][load-leveling-pattern].</span></span>

### <a name="isolate-critical-resources"></a><span data-ttu-id="89427-423">隔离关键资源</span><span class="sxs-lookup"><span data-stu-id="89427-423">Isolate critical resources</span></span>
<span data-ttu-id="89427-424">一个子系统发生故障有时会造成连锁反应，导致应用程序的其他部分发生故障。</span><span class="sxs-lookup"><span data-stu-id="89427-424">Failures in one subsystem can sometimes cascade, causing failures in other parts of the application.</span></span> <span data-ttu-id="89427-425">如果某个故障导致某些资源（例如线程或套接字）无法及时释放，导致资源耗尽，则可能就会发生这种连锁反应。</span><span class="sxs-lookup"><span data-stu-id="89427-425">This can happen if a failure causes some resources, such as threads or sockets, not to get freed in a timely manner, leading to resource exhaustion.</span></span> 

<span data-ttu-id="89427-426">为了避免此问题，可将系统分区为独立的组，使一个分区中的故障不会导致整个系统瘫痪。</span><span class="sxs-lookup"><span data-stu-id="89427-426">To avoid this, you can partition a system into isolated groups, so that a failure in one partition does not bring down the entire system.</span></span> <span data-ttu-id="89427-427">此方法有时称为隔离模式。</span><span class="sxs-lookup"><span data-stu-id="89427-427">This technique is sometimes called the Bulkhead pattern.</span></span>

<span data-ttu-id="89427-428">示例:</span><span class="sxs-lookup"><span data-stu-id="89427-428">Examples:</span></span>

* <span data-ttu-id="89427-429">将数据库分区（例如，按租户），并为每个分区分配独立的 Web 服务器实例池。</span><span class="sxs-lookup"><span data-stu-id="89427-429">Partition a database (for example, by tenant) and assign a separate pool of web server instances for each partition.</span></span>  
* <span data-ttu-id="89427-430">使用单独的线程池来隔离对不同服务发出的调用。</span><span class="sxs-lookup"><span data-stu-id="89427-430">Use separate thread pools to isolate calls to different services.</span></span> <span data-ttu-id="89427-431">这有助于防止其中一个服务发生故障时出现连发故障。</span><span class="sxs-lookup"><span data-stu-id="89427-431">This helps to prevent cascading failures if one of the services fails.</span></span> <span data-ttu-id="89427-432">有关示例，请参阅 Netflix [Hystrix 库][hystrix]。</span><span class="sxs-lookup"><span data-stu-id="89427-432">For an example, see the Netflix [Hystrix library][hystrix].</span></span>
* <span data-ttu-id="89427-433">使用[容器][containers]来限制特定子系统可用的资源。</span><span class="sxs-lookup"><span data-stu-id="89427-433">Use [containers][containers] to limit the resources available to a particular subsystem.</span></span> 

![复合 SLA](./images/bulkhead.png)

### <a name="apply-compensating-transactions"></a><span data-ttu-id="89427-435">应用补偿事务</span><span class="sxs-lookup"><span data-stu-id="89427-435">Apply compensating transactions</span></span>
<span data-ttu-id="89427-436">补偿事务是用于消除另一个已完成的事务所造成的影响的事务。</span><span class="sxs-lookup"><span data-stu-id="89427-436">A compensating transaction is a transaction that undoes the effects of another completed transaction.</span></span>

<span data-ttu-id="89427-437">在分布式系统中，可能很难实现较强的事务一致性。</span><span class="sxs-lookup"><span data-stu-id="89427-437">In a distributed system, it can be very difficult to achieve strong transactional consistency.</span></span> <span data-ttu-id="89427-438">补偿事务是使用一系列可在每个步骤中撤消的较小独立事务，实现一致性的方式。</span><span class="sxs-lookup"><span data-stu-id="89427-438">Compensating transactions are a way to achieve consistency by using a series of smaller, individual transactions that can be undone at each step.</span></span>

<span data-ttu-id="89427-439">例如，若要预订行程，客户可能需要预约租车、客房和航班。</span><span class="sxs-lookup"><span data-stu-id="89427-439">For example, to book a trip, a customer might reserve a car, a hotel room, and a flight.</span></span> <span data-ttu-id="89427-440">如果其中的任何步骤失败，整个操作就会失败。</span><span class="sxs-lookup"><span data-stu-id="89427-440">If any of these steps fails, the entire operation fails.</span></span> <span data-ttu-id="89427-441">我们可以针对每个步骤定义一个补偿事务，而不用尝试对整个操作使用单个分布式事务。</span><span class="sxs-lookup"><span data-stu-id="89427-441">Instead of trying to use a single distributed transaction for the entire operation, you can define a compensating transaction for each step.</span></span> <span data-ttu-id="89427-442">例如，若要撤消租车，可以取消预订。</span><span class="sxs-lookup"><span data-stu-id="89427-442">For example, to undo a car reservation, you cancel the reservation.</span></span> <span data-ttu-id="89427-443">为了完成整个操作，协调人员会执行每个步骤。</span><span class="sxs-lookup"><span data-stu-id="89427-443">In order to complete the whole operation, a coordinator executes each step.</span></span> <span data-ttu-id="89427-444">如果任一步骤失败，协调人员可应用补偿事务，以撤消前面已完成的任何步骤。</span><span class="sxs-lookup"><span data-stu-id="89427-444">If any step fails, the coordinator applies compensating transactions to undo any steps that were completed.</span></span> 

<span data-ttu-id="89427-445">有关详细信息，请参阅[补偿事务模式][compensating-transaction-pattern]。</span><span class="sxs-lookup"><span data-stu-id="89427-445">For more information, see [Compensating Transaction Pattern][compensating-transaction-pattern].</span></span> 


## <a name="testing-for-resiliency"></a><span data-ttu-id="89427-446">测试复原能力</span><span class="sxs-lookup"><span data-stu-id="89427-446">Testing for resiliency</span></span>
<span data-ttu-id="89427-447">一般情况下，无法像测试应用程序功能（运行单元测试等）一样来测试复原能力。</span><span class="sxs-lookup"><span data-stu-id="89427-447">Generally, you can't test resiliency in the same way that you test application functionality (by running unit tests and so on).</span></span> <span data-ttu-id="89427-448">必须在故障状态下测试端到端工作负荷的执行情况，而这种状态只能间歇性地出现。</span><span class="sxs-lookup"><span data-stu-id="89427-448">Instead, you must test how the end-to-end workload performs under failure conditions which only occur intermittently.</span></span>

<span data-ttu-id="89427-449">测试是一个迭代过程。</span><span class="sxs-lookup"><span data-stu-id="89427-449">Testing is an iterative process.</span></span> <span data-ttu-id="89427-450">需要测试应用程序、测量结果、分析并解决出现的任何故障，并重复该过程。</span><span class="sxs-lookup"><span data-stu-id="89427-450">Test the application, measure the outcome, analyze and address any failures that result, and repeat the process.</span></span>

<span data-ttu-id="89427-451">**故障注入测试**。</span><span class="sxs-lookup"><span data-stu-id="89427-451">**Fault injection testing**.</span></span> <span data-ttu-id="89427-452">通过触发实际故障或模拟故障，测试系统在故障期间的复原能力。</span><span class="sxs-lookup"><span data-stu-id="89427-452">Test the resiliency of the system during failures, either by triggering actual failures or by simulating them.</span></span> <span data-ttu-id="89427-453">下面提供了一些常见的故障情景供测试：</span><span class="sxs-lookup"><span data-stu-id="89427-453">Here are some common failure scenarios to test:</span></span>

* <span data-ttu-id="89427-454">关闭 VM 实例。</span><span class="sxs-lookup"><span data-stu-id="89427-454">Shut down VM instances.</span></span>
* <span data-ttu-id="89427-455">进程崩溃。</span><span class="sxs-lookup"><span data-stu-id="89427-455">Crash processes.</span></span>
* <span data-ttu-id="89427-456">证书过期。</span><span class="sxs-lookup"><span data-stu-id="89427-456">Expire certificates.</span></span>
* <span data-ttu-id="89427-457">更改访问密钥。</span><span class="sxs-lookup"><span data-stu-id="89427-457">Change access keys.</span></span>
* <span data-ttu-id="89427-458">关闭域控制器上的 DNS 服务。</span><span class="sxs-lookup"><span data-stu-id="89427-458">Shut down the DNS service on domain controllers.</span></span>
* <span data-ttu-id="89427-459">限制可用的系统资源，例如 RAM 或线程数。</span><span class="sxs-lookup"><span data-stu-id="89427-459">Limit available system resources, such as RAM or number of threads.</span></span>
* <span data-ttu-id="89427-460">卸载磁盘。</span><span class="sxs-lookup"><span data-stu-id="89427-460">Unmount disks.</span></span>
* <span data-ttu-id="89427-461">重新部署 VM。</span><span class="sxs-lookup"><span data-stu-id="89427-461">Redeploy a VM.</span></span>

<span data-ttu-id="89427-462">测量恢复时间，并验证是否满足业务要求。</span><span class="sxs-lookup"><span data-stu-id="89427-462">Measure the recovery times and verify that your business requirements are met.</span></span> <span data-ttu-id="89427-463">同时测试故障模式的组合。</span><span class="sxs-lookup"><span data-stu-id="89427-463">Test combinations of failure modes as well.</span></span> <span data-ttu-id="89427-464">确保故障不会造成连锁反应，并且能够以隔离的方式予以处理。</span><span class="sxs-lookup"><span data-stu-id="89427-464">Make sure that failures don't cascade, and are handled in an isolated way.</span></span>

<span data-ttu-id="89427-465">这是为何有必要在设计阶段分析潜在故障点的另一个原因。</span><span class="sxs-lookup"><span data-stu-id="89427-465">This is another reason why it's important to analyze possible failure points during the design phase.</span></span> <span data-ttu-id="89427-466">该分析的结果应该成为测试计划的输入。</span><span class="sxs-lookup"><span data-stu-id="89427-466">The results of that analysis should be inputs into your test plan.</span></span>

<span data-ttu-id="89427-467">**负载测试**。</span><span class="sxs-lookup"><span data-stu-id="89427-467">**Load testing**.</span></span> <span data-ttu-id="89427-468">使用 [Visual Studio Team Services][vsts] 或 [Apache JMeter][jmeter] 等工具对应用程序进行负载测试。</span><span class="sxs-lookup"><span data-stu-id="89427-468">Load test the application using a tool such as [Visual Studio Team Services][vsts] or [Apache JMeter][jmeter].</span></span> <span data-ttu-id="89427-469">要识别只有在承受负载的情况下才会发生的故障（例如，后端数据库瘫痪，或者服务受限制），执行负载测试至关重要。</span><span class="sxs-lookup"><span data-stu-id="89427-469">Load testing is crucial for identifying failures that only happen under load, such as the backend database being overwhelmed or service throttling.</span></span> <span data-ttu-id="89427-470">使用生产数据或尽量与生产数据接近的合成数据测试峰值负载。</span><span class="sxs-lookup"><span data-stu-id="89427-470">Test for peak load, using production data or synthetic data that is as close to production data as possible.</span></span> <span data-ttu-id="89427-471">目标是检查应用程序在实际条件下的行为方式。</span><span class="sxs-lookup"><span data-stu-id="89427-471">The goal is to see how the application behaves under real-world conditions.</span></span>   

## <a name="resilient-deployment"></a><span data-ttu-id="89427-472">可复原的部署</span><span class="sxs-lookup"><span data-stu-id="89427-472">Resilient deployment</span></span>
<span data-ttu-id="89427-473">将应用程序部署到生产环境后，更新操作就成了一个可能的出错来源。</span><span class="sxs-lookup"><span data-stu-id="89427-473">Once an application is deployed to production, updates are a possible source of errors.</span></span> <span data-ttu-id="89427-474">在最坏的情况下，不当的更新可能导致停机。</span><span class="sxs-lookup"><span data-stu-id="89427-474">In the worst case, a bad update can cause downtime.</span></span> <span data-ttu-id="89427-475">为了避免此问题，部署过程必须可预测且可重复。</span><span class="sxs-lookup"><span data-stu-id="89427-475">To avoid this, the deployment process must be predictable and repeatable.</span></span> <span data-ttu-id="89427-476">部署包括预配 Azure 资源、部署应用程序代码和应用配置设置。</span><span class="sxs-lookup"><span data-stu-id="89427-476">Deployment includes provisioning Azure resources, deploying application code, and applying configuration settings.</span></span> <span data-ttu-id="89427-477">更新可能包括上述所有三个步骤，或其中的一部分。</span><span class="sxs-lookup"><span data-stu-id="89427-477">An update may involve all three, or a subset.</span></span> 

<span data-ttu-id="89427-478">要害的一点在于，手动部署容易出错。</span><span class="sxs-lookup"><span data-stu-id="89427-478">The crucial point is that manual deployments are prone to error.</span></span> <span data-ttu-id="89427-479">因此，我们建议采用可按需运行的自动化幂等过程，在某个环节出错时，可以重新运行。</span><span class="sxs-lookup"><span data-stu-id="89427-479">Therefore, it's recommended to have an automated, idempotent process that you can run on demand, and re-run if something fails.</span></span> 

* <span data-ttu-id="89427-480">使用资源管理器模板自动预配 Azure 资源。</span><span class="sxs-lookup"><span data-stu-id="89427-480">Use Resource Manager templates to automate provisioning of Azure resources.</span></span>
* <span data-ttu-id="89427-481">使用 [Azure 自动化 Desired State Configuration][dsc] (DSC) 配置 VM。</span><span class="sxs-lookup"><span data-stu-id="89427-481">Use [Azure Automation Desired State Configuration][dsc] (DSC) to configure VMs.</span></span>
* <span data-ttu-id="89427-482">针对应用程序代码使用自动部署过程。</span><span class="sxs-lookup"><span data-stu-id="89427-482">Use an automated deployment process for application code.</span></span>

<span data-ttu-id="89427-483">“基础结构即代码”和“不可变基础结构”是与可复原部署相关的两个概念。</span><span class="sxs-lookup"><span data-stu-id="89427-483">Two concepts related to resilient deployment are *infrastructure as code* and *immutable infrastructure*.</span></span>

* <span data-ttu-id="89427-484">“基础结构即代码”是指使用代码来预配和配置基础结构的做法。</span><span class="sxs-lookup"><span data-stu-id="89427-484">**Infrastructure as code** is the practice of using code to provision and configure infrastructure.</span></span> <span data-ttu-id="89427-485">“基础结构即代码”可以使用声明性方法或命令性方法（或两者的组合）。</span><span class="sxs-lookup"><span data-stu-id="89427-485">Infrastructure as code may use a declarative approach or an imperative approach (or a combination of both).</span></span> <span data-ttu-id="89427-486">资源管理器模板就是声明性方法的一个例子。</span><span class="sxs-lookup"><span data-stu-id="89427-486">Resource Manager templates are an example of a declarative approach.</span></span> <span data-ttu-id="89427-487">PowerShell 脚本是命令性方法的例子。</span><span class="sxs-lookup"><span data-stu-id="89427-487">PowerShell scripts are an example of an imperative approach.</span></span>
* <span data-ttu-id="89427-488">“不可变基础结构”是指在将基础结构部署到生产环境后不应对其进行修改的原则。</span><span class="sxs-lookup"><span data-stu-id="89427-488">**Immutable infrastructure** is the principle that you shouldn’t modify infrastructure after it’s deployed to production.</span></span> <span data-ttu-id="89427-489">否则，可能会陷入这种状态：应用即席更改后，很难确切地知道哪些内容已更改，且很难对系统做出推断。</span><span class="sxs-lookup"><span data-stu-id="89427-489">Otherwise, you can get into a state where ad hoc changes have been applied, so it's hard to know exactly what changed, and hard to reason about the system.</span></span> 

<span data-ttu-id="89427-490">另一个问题是如何推出应用程序更新。</span><span class="sxs-lookup"><span data-stu-id="89427-490">Another question is how to roll out an application update.</span></span> <span data-ttu-id="89427-491">我们建议采用蓝绿部署或“金丝雀发布”方法，以高度受控的方式推送更新，尽量减小不当部署造成的影响。</span><span class="sxs-lookup"><span data-stu-id="89427-491">We recommend techniques such as blue-green deployment or canary releases, which push updates in highly controlled way to minimize possible impacts from a bad deployment.</span></span>

* <span data-ttu-id="89427-492">[蓝绿部署][blue-green]方法将更新部署到独立于实时应用程序的生产环境。</span><span class="sxs-lookup"><span data-stu-id="89427-492">[Blue-green deployment][blue-green] is a technique where an update is deployed into a production environment separate from the live application.</span></span> <span data-ttu-id="89427-493">验证部署后，可将流量改为路由到更新的版本。</span><span class="sxs-lookup"><span data-stu-id="89427-493">After you validate the deployment, switch the traffic routing to the updated version.</span></span> <span data-ttu-id="89427-494">例如，Azure 应用服务 Web 应用会在过渡槽中启用此方法。</span><span class="sxs-lookup"><span data-stu-id="89427-494">For example, Azure App Service Web Apps enables this with staging slots.</span></span>
* <span data-ttu-id="89427-495">[金丝雀发布][canary-release]类似于蓝绿部署。</span><span class="sxs-lookup"><span data-stu-id="89427-495">[Canary releases][canary-release] are similar to blue-green deployments.</span></span> <span data-ttu-id="89427-496">使用此方法时，我们不是将所有流量切换到更新的版本，而是通过将一部分流量路由到新部署，向少部分用户推出更新。</span><span class="sxs-lookup"><span data-stu-id="89427-496">Instead of switching all traffic to the updated version, you roll out the update to a small percentage of users, by routing a portion of the traffic to the new deployment.</span></span> <span data-ttu-id="89427-497">如果出现问题，则回退并还原到旧部署。</span><span class="sxs-lookup"><span data-stu-id="89427-497">If there is a problem, back off and revert to the old deployment.</span></span> <span data-ttu-id="89427-498">否则，将更多的流量路由到新版本，直到路由的流量达到 100%。</span><span class="sxs-lookup"><span data-stu-id="89427-498">Otherwise, route more of the traffic to the new version, until it gets 100% of the traffic.</span></span>

<span data-ttu-id="89427-499">不管采用哪种方法，都应该确保在新版本无法正常运行的情况下，可以回滚到上次已知正常的部署。</span><span class="sxs-lookup"><span data-stu-id="89427-499">Whatever approach you take, make sure that you can roll back to the last-known-good deployment, in case the new version is not functioning.</span></span> <span data-ttu-id="89427-500">此外，如果出错，应用程序日志必须指出哪个版本导致了错误。</span><span class="sxs-lookup"><span data-stu-id="89427-500">Also, if errors occur, the application logs must indicate which version caused the error.</span></span> 

## <a name="monitoring-and-diagnostics"></a><span data-ttu-id="89427-501">监视和诊断</span><span class="sxs-lookup"><span data-stu-id="89427-501">Monitoring and diagnostics</span></span>
<span data-ttu-id="89427-502">监视和诊断对于复原能力至关重要。</span><span class="sxs-lookup"><span data-stu-id="89427-502">Monitoring and diagnostics are crucial for resiliency.</span></span> <span data-ttu-id="89427-503">如果某个组件发生故障，我们需要知道该组件已发生故障，并深入分析故障原因。</span><span class="sxs-lookup"><span data-stu-id="89427-503">If something fails, you need to know that it failed, and you need insights into the cause of the failure.</span></span> 

<span data-ttu-id="89427-504">监视大规模分布式系统是一个很大的难题。</span><span class="sxs-lookup"><span data-stu-id="89427-504">Monitoring a large-scale distributed system poses a significant challenge.</span></span> <span data-ttu-id="89427-505">假设某个应用程序在几十个 VM 上运行 &mdash; 逐个地登录每个 VM，仔细查看日志文件，再尝试排查问题的做法不切实际。</span><span class="sxs-lookup"><span data-stu-id="89427-505">Think about an application that runs on a few dozen VMs &mdash; it's not practical to log into each VM, one at a time, and look through log files, trying to troubleshoot a problem.</span></span> <span data-ttu-id="89427-506">此外，VM 实例数可能不是恒定的。</span><span class="sxs-lookup"><span data-stu-id="89427-506">Moreover, the number of VM instances is probably not static.</span></span> <span data-ttu-id="89427-507">VM 会随着应用程序的缩减和扩展而不断添加或删除，有时，某个实例可能会发生故障，需要重新预配。</span><span class="sxs-lookup"><span data-stu-id="89427-507">VMs get added and removed as the application scales in and out, and occasionally an instance may fail and need to be reprovisioned.</span></span> <span data-ttu-id="89427-508">此外，典型的云应用程序可能会使用多个数据存储（Azure 存储、SQL 数据库、Cosmos DB、Redis 缓存），而单个用户操作可能跨多个子系统。</span><span class="sxs-lookup"><span data-stu-id="89427-508">In addition, a typical cloud application might use multiple data stores (Azure storage, SQL Database, Cosmos DB, Redis cache), and a single user action may span multiple subsystems.</span></span> 

<span data-ttu-id="89427-509">可将监视和诊断过程视为包含多个不同阶段的管道：</span><span class="sxs-lookup"><span data-stu-id="89427-509">You can think of the monitoring and diagnostics process as a pipeline with several distinct stages:</span></span>

![复合 SLA](./images/monitoring.png)

* <span data-ttu-id="89427-511">**检测**</span><span class="sxs-lookup"><span data-stu-id="89427-511">**Instrumentation**.</span></span> <span data-ttu-id="89427-512">要监视和诊断的原始数据来自各种源，包括应用程序日志、Web 服务器日志、OS 性能计数器、数据库日志和 Azure 平台中内置的诊断。</span><span class="sxs-lookup"><span data-stu-id="89427-512">The raw data for monitoring and diagnostics comes from a variety of sources, including application logs, web server logs, OS performance counters, database logs, and diagnostics built into the Azure platform.</span></span> <span data-ttu-id="89427-513">大多数 Azure 服务提供诊断功能，可用于确定问题的原因。</span><span class="sxs-lookup"><span data-stu-id="89427-513">Most Azure services have a diagnostics feature that you can use to determine the cause of problems.</span></span>
* <span data-ttu-id="89427-514">**收集和存储**。</span><span class="sxs-lookup"><span data-stu-id="89427-514">**Collection and storage**.</span></span> <span data-ttu-id="89427-515">可以使用各种格式将原始检测数据保存在不同的位置（例如，应用程序跟踪日志、IIS 日志、性能计数器）。</span><span class="sxs-lookup"><span data-stu-id="89427-515">Raw instrumentation data can be held in various locations and with various formats (e.g., application trace logs, IIS logs, performance counters).</span></span> <span data-ttu-id="89427-516">可以收集、合并这些不同源中的数据，并将其放入可靠的存储。</span><span class="sxs-lookup"><span data-stu-id="89427-516">These disparate sources are collected, consolidated, and put into reliable storage.</span></span>
* <span data-ttu-id="89427-517">**分析和诊断**。</span><span class="sxs-lookup"><span data-stu-id="89427-517">**Analysis and diagnosis**.</span></span> <span data-ttu-id="89427-518">合并数据后，可对其进行分析，以排查问题并提供应用程序运行状况的总体视图。</span><span class="sxs-lookup"><span data-stu-id="89427-518">After the data is consolidated, it can be analyzed to troubleshoot issues and provide an overall view of application health.</span></span>
* <span data-ttu-id="89427-519">**可视化和警报**。</span><span class="sxs-lookup"><span data-stu-id="89427-519">**Visualization and alerts**.</span></span> <span data-ttu-id="89427-520">在此阶段，将以适当的方式呈现遥测数据，使操作员能够快速发现问题或趋势。</span><span class="sxs-lookup"><span data-stu-id="89427-520">In this stage, telemetry data is presented in such a way that an operator can quickly notice problems or trends.</span></span> <span data-ttu-id="89427-521">示例包括仪表板或电子邮件警报。</span><span class="sxs-lookup"><span data-stu-id="89427-521">Example include dashboards or email alerts.</span></span>  

<span data-ttu-id="89427-522">监视与故障检测不同。</span><span class="sxs-lookup"><span data-stu-id="89427-522">Monitoring is not the same as failure detection.</span></span> <span data-ttu-id="89427-523">例如，应用程序可以检测暂时性错误然后重试，这样就不会导致停机。</span><span class="sxs-lookup"><span data-stu-id="89427-523">For example, your application might detect a transient error and retry, resulting in no downtime.</span></span> <span data-ttu-id="89427-524">但是，它还应该记录重试操作，使我们能够监视错误率，了解应用程序的大致运行状况。</span><span class="sxs-lookup"><span data-stu-id="89427-524">But it should also log the retry operation, so that you can monitor the error rate, in order to get an overall picture of application health.</span></span> 

<span data-ttu-id="89427-525">应用程序日志是诊断数据的重要来源。</span><span class="sxs-lookup"><span data-stu-id="89427-525">Application logs are an important source of diagnostics data.</span></span> <span data-ttu-id="89427-526">在应用程序日志记录方面，最佳做法包括：</span><span class="sxs-lookup"><span data-stu-id="89427-526">Best practices for application logging include:</span></span>

* <span data-ttu-id="89427-527">在生产环境中记录日志。</span><span class="sxs-lookup"><span data-stu-id="89427-527">Log in production.</span></span> <span data-ttu-id="89427-528">否则，在最需要洞察数据的时候却缺少此类数据。</span><span class="sxs-lookup"><span data-stu-id="89427-528">Otherwise, you lose insight where you need it most.</span></span>
* <span data-ttu-id="89427-529">记录服务边界的事件。</span><span class="sxs-lookup"><span data-stu-id="89427-529">Log events at service boundaries.</span></span> <span data-ttu-id="89427-530">包含跨服务边界流动的关联 ID。</span><span class="sxs-lookup"><span data-stu-id="89427-530">Include a correlation ID that flows across service boundaries.</span></span> <span data-ttu-id="89427-531">如果某个事务流经多个服务，而其中一个服务发生故障，则关联 ID 可帮助查明事务失败的原因。</span><span class="sxs-lookup"><span data-stu-id="89427-531">If a transaction flows through multiple services and one of them fails, the correlation ID will help you pinpoint why the transaction failed.</span></span>
* <span data-ttu-id="89427-532">使用语义日志记录，也称为结构化日志记录。</span><span class="sxs-lookup"><span data-stu-id="89427-532">Use semantic logging, also known as structured logging.</span></span> <span data-ttu-id="89427-533">使用非结构化日志很难将日志数据的使用和分析自动化，而云规模的运营需要这种自动化技术。</span><span class="sxs-lookup"><span data-stu-id="89427-533">Unstructured logs make it hard to automate the consumption and analysis of the log data, which is needed at cloud scale.</span></span>
* <span data-ttu-id="89427-534">使用异步日志记录。</span><span class="sxs-lookup"><span data-stu-id="89427-534">Use asynchronous logging.</span></span> <span data-ttu-id="89427-535">否则，日志记录系统本身可能导致应用程序发生故障，因为它会导致请求进入备份队列，使请求在等待写入日志记录事件时阻塞。</span><span class="sxs-lookup"><span data-stu-id="89427-535">Otherwise, the logging system itself can cause the application to fail by causing requests to back up, as they block while waiting to write a logging event.</span></span>
* <span data-ttu-id="89427-536">应用程序日志记录与审核不同。</span><span class="sxs-lookup"><span data-stu-id="89427-536">Application logging is not the same as auditing.</span></span> <span data-ttu-id="89427-537">审核可能是出于符合性或法规原因执行的。</span><span class="sxs-lookup"><span data-stu-id="89427-537">Auditing may be done for compliance or regulatory reasons.</span></span> <span data-ttu-id="89427-538">在这种情况下，审核记录必须完整，处理事务时不可丢弃任何记录。</span><span class="sxs-lookup"><span data-stu-id="89427-538">As such, audit records must be complete, and it's not acceptable to drop any while processing transactions.</span></span> <span data-ttu-id="89427-539">如果应用程序需要审核，应该独立于诊断日志记录执行审核。</span><span class="sxs-lookup"><span data-stu-id="89427-539">If an application requires auditing, this should be kept separate from diagnostics logging.</span></span> 

<span data-ttu-id="89427-540">有关监视和诊断的详细信息，请参阅[监视和诊断指南][monitoring-guidance]。</span><span class="sxs-lookup"><span data-stu-id="89427-540">For more information about monitoring and diagnostics, see [Monitoring and diagnostics guidance][monitoring-guidance].</span></span>

## <a name="manual-failure-responses"></a><span data-ttu-id="89427-541">手动故障响应</span><span class="sxs-lookup"><span data-stu-id="89427-541">Manual failure responses</span></span>
<span data-ttu-id="89427-542">前面的部分着重于自动化恢复策略，这是实现高可用性的关键所在。</span><span class="sxs-lookup"><span data-stu-id="89427-542">Previous sections have focused on automated recovery strategies, which are critical for high availability.</span></span> <span data-ttu-id="89427-543">但是，有时需要人工干预。</span><span class="sxs-lookup"><span data-stu-id="89427-543">However, sometimes manual intervention is needed.</span></span>

* <span data-ttu-id="89427-544">**警报**。</span><span class="sxs-lookup"><span data-stu-id="89427-544">**Alerts**.</span></span> <span data-ttu-id="89427-545">监视应用程序中是否出现了可能需要主动干预的警示。</span><span class="sxs-lookup"><span data-stu-id="89427-545">Monitor your application for warning signs that may require proactive intervention.</span></span> <span data-ttu-id="89427-546">例如，如果看到 SQL 数据库或 Cosmos DB 在不断地限制应用程序，则可能需要增大数据库容量或优化查询。</span><span class="sxs-lookup"><span data-stu-id="89427-546">For example, if you see that SQL Database or Cosmos DB consistently throttles your application, you might need to increase your database capacity or optimize your queries.</span></span> <span data-ttu-id="89427-547">在此示例中，即使应用程序能够以透明方式处理限制错误，遥测也仍应该引发警报，使我们能够跟进问题。</span><span class="sxs-lookup"><span data-stu-id="89427-547">In this example, even though the application might handle the throttling errors transparently, your telemetry should still raise an alert so that you can follow up.</span></span>  
* <span data-ttu-id="89427-548">**手动故障转移**。</span><span class="sxs-lookup"><span data-stu-id="89427-548">**Manual failover**.</span></span> <span data-ttu-id="89427-549">某些系统无法自动故障转移，需要手动故障转移。</span><span class="sxs-lookup"><span data-stu-id="89427-549">Some systems cannot fail over automatically and require a manual failover.</span></span> 
* <span data-ttu-id="89427-550">**操作就绪性测试**。</span><span class="sxs-lookup"><span data-stu-id="89427-550">**Operational readiness testing**.</span></span> <span data-ttu-id="89427-551">如果应用程序故障转移到了次要区域，我们应该在故障回复到主要区域之前执行操作就绪性测试。</span><span class="sxs-lookup"><span data-stu-id="89427-551">If your application fails over to a secondary region, you should perform an operational readiness test before you fail back to the primary region.</span></span> <span data-ttu-id="89427-552">该项测试应该验证主要区域是否正常，可以再次接收流量。</span><span class="sxs-lookup"><span data-stu-id="89427-552">The test should verify that the primary region is healthy and ready to receive traffic again.</span></span>
* <span data-ttu-id="89427-553">**数据一致性检查**。</span><span class="sxs-lookup"><span data-stu-id="89427-553">**Data consistency check**.</span></span> <span data-ttu-id="89427-554">如果数据存储发生故障，原因可能是该存储再次可用后存在数据不一致情况，尤其是数据是复制过来的情况下。</span><span class="sxs-lookup"><span data-stu-id="89427-554">If a failure happens in a data store, there may be data inconsistencies when the store becomes available again, especially if the data was replicated.</span></span> 
* <span data-ttu-id="89427-555">**从备份还原**。</span><span class="sxs-lookup"><span data-stu-id="89427-555">**Restoring from backup**.</span></span> <span data-ttu-id="89427-556">例如，如果 SQL 数据库遇到区域性服务中断，我们可以从最新备份异地还原数据库。</span><span class="sxs-lookup"><span data-stu-id="89427-556">For example, if SQL Database experiences a regional outage, you can geo-restore the database from the latest backup.</span></span>

<span data-ttu-id="89427-557">阐述和测试灾难恢复计划。</span><span class="sxs-lookup"><span data-stu-id="89427-557">Document and test your disaster recovery plan.</span></span> <span data-ttu-id="89427-558">评估应用程序故障造成的业务影响。</span><span class="sxs-lookup"><span data-stu-id="89427-558">Evaluate the business impact of application failures.</span></span> <span data-ttu-id="89427-559">尽量将过程自动化，并阐述所有手动步骤，例如，手动故障转移或者从备份还原数据的步骤。</span><span class="sxs-lookup"><span data-stu-id="89427-559">Automate the process as much as possible, and document any manual steps, such as manual failover or data restoration from backups.</span></span> <span data-ttu-id="89427-560">定期测试灾难恢复过程，以验证并改进计划。</span><span class="sxs-lookup"><span data-stu-id="89427-560">Regularly test your disaster recovery process to validate and improve the plan.</span></span> 

## <a name="summary"></a><span data-ttu-id="89427-561">摘要</span><span class="sxs-lookup"><span data-stu-id="89427-561">Summary</span></span>
<span data-ttu-id="89427-562">本文整体性地讨论了复原能力，并将重点放在云的某些独特难题上。</span><span class="sxs-lookup"><span data-stu-id="89427-562">This article discussed resiliency from a holistic perspective, emphasizing some of the unique challenges of the cloud.</span></span> <span data-ttu-id="89427-563">这些难题包括云计算的分散性、市售硬件的使用，以及暂时性网络故障的存在。</span><span class="sxs-lookup"><span data-stu-id="89427-563">These include the distributed nature of cloud computing, the use of commodity hardware, and the presence of transient network faults.</span></span>

<span data-ttu-id="89427-564">下面是本文阐述的要点：</span><span class="sxs-lookup"><span data-stu-id="89427-564">Here are the major points to take away from this article:</span></span>

* <span data-ttu-id="89427-565">复原能力可提高可用性，减少故障恢复平均时间。</span><span class="sxs-lookup"><span data-stu-id="89427-565">Resiliency leads to higher availability, and lower mean time to recover from failures.</span></span> 
* <span data-ttu-id="89427-566">在云中实现复原能力需要采用有别于传统本地解决方案的技术组合。</span><span class="sxs-lookup"><span data-stu-id="89427-566">Achieving resiliency in the cloud requires a different set of techniques from traditional on-premises solutions.</span></span> 
* <span data-ttu-id="89427-567">复原不是巧合。</span><span class="sxs-lookup"><span data-stu-id="89427-567">Resiliency does not happen by accident.</span></span> <span data-ttu-id="89427-568">必须从一开始就规划并建立复原能力。</span><span class="sxs-lookup"><span data-stu-id="89427-568">It must be designed and built in from the start.</span></span>
* <span data-ttu-id="89427-569">复原涉及到应用程序生命周期的每个环节：从规划、编程到运营。</span><span class="sxs-lookup"><span data-stu-id="89427-569">Resiliency touches every part of the application lifecycle, from planning and coding to operations.</span></span>
* <span data-ttu-id="89427-570">此外，还要进行测试和监视！</span><span class="sxs-lookup"><span data-stu-id="89427-570">Test and monitor!</span></span>


<!-- links -->

[blue-green]: http://martinfowler.com/bliki/BlueGreenDeployment.html
[canary-release]: http://martinfowler.com/bliki/CanaryRelease.html
[circuit-breaker-pattern]: https://msdn.microsoft.com/library/dn589784.aspx
[compensating-transaction-pattern]: https://msdn.microsoft.com/library/dn589804.aspx
[containers]: https://en.wikipedia.org/wiki/Operating-system-level_virtualization
[dsc]: /azure/automation/automation-dsc-overview
[contingency-planning-guide]: http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-34r1.pdf
[fma]: failure-mode-analysis.md
[hystrix]: http://techblog.netflix.com/2012/11/hystrix.html
[jmeter]: http://jmeter.apache.org/
[load-leveling-pattern]: ../patterns/queue-based-load-leveling.md
[monitoring-guidance]: ../best-practices/monitoring.md
[ra-basic-web]: ../reference-architectures/app-service-web-app/basic-web-app.md
[ra-multi-vm]: ../reference-architectures/virtual-machines-windows/multi-vm.md
[checklist]: ../checklist/resiliency.md
[retry-pattern]: ../patterns/retry.md
[retry-service-specific guidance]: ../best-practices/retry-service-specific.md
[sla]: https://azure.microsoft.com/support/legal/sla/
[throttling-pattern]: ../patterns/throttling.md
[tm]: https://azure.microsoft.com/services/traffic-manager/
[tm-failover]: /azure/traffic-manager/traffic-manager-monitoring
[tm-sla]: https://azure.microsoft.com/support/legal/sla/traffic-manager/v1_0/
[vsts]: https://www.visualstudio.com/features/vso-cloud-load-testing-vs.aspx
